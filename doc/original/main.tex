\documentclass{llncs}
%%
%\setlength{\textheight}{23cm}
\setlength{\textwidth}{13.5cm}
\advance\evensidemargin by -.65cm
\advance\oddsidemargin by -.65cm
%\setlength{\hoffset}{-1cm}
%\renewcommand{\baselinestretch}{0.95}

%\setlength{\abovedisplayskip}{3pt plus 0pt minus 0pt}
%\setlength{\abovedisplayskip}{3pt}
%\setlength{\abovedisplayshortskip}{3pt}
%\setlength{\belowdisplayskip}{3pt}
%\setlength{\belowdisplayshortskip}{3pt}

\usepackage{fleqn}
\usepackage{listings}
\usepackage{math}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{bcprules}
\usepackage[scaled=0.848971]{luximono} % This is for 11 pt Default font
\usepackage[T1]{fontenc}

% Prooftree formatting
\usepackage{prooftree}

% support for generating PDF files
%\newif\ifpdf
%    \ifx\pdfoutput\undefined
%    \pdffalse
%\else
%    \pdftrue
%    \pdfoutput=1
%\fi

%versions
% Use dependent function types
\newif\ifdep\depfalse

\lstset{
  literate=
  {=>}{$\Rightarrow\;$}{2}
  {<:}{$<:\;$}{1}
}

\lstdefinelanguage{scala}{% 
       morekeywords={% 
                try, catch, throw, private, public, protected, import, package, implicit, final, package, trait, type, class, val, def, var, if, for, this, else, extends, with, while, new, abstract, object, case, match, sealed,override},
         sensitive=t, % 
   morecomment=[s]{/*}{*/},morecomment=[l]{\//},% 
   mathescape,
%   escapeinside={/*\%}{*/},%
   rangeprefix= /*< ,rangesuffix= >*/,%
   morestring=[d]{"}% 
 }
 
\lstset{breaklines=true,language=scala} 

\def\c{\lstinline}  % shorter version so you can write \c|String[Foo]|
                    % -- \def must be in same file as uses for this to
                    % work...
\newcommand{\lstref}[1]{Listing~\ref{#1}}
\newcommand{\Lstref}[1]{Listing~\ref{#1}} % only capitalise at beginning of sentence?
\newcommand{\secref}[1]{Section~\ref{#1}}
\newcommand{\Secref}[1]{Section~\ref{#1}} % only capitalise at beginning of sentence?



% \lstset{basicstyle=\footnotesize\ttfamily, breaklines=true, language=scala, tabsize=2, columns=fixed, mathescape=false,includerangemarker=false}
% thank you, Burak 
% (lstset tweaking stolen from
% http://lampsvn.epfl.ch/svn-repos/scala/scala/branches/typestate/docs/tstate-report/datasway.tex)
\lstset{
    xleftmargin=2em,%
    framesep=5pt,%
    frame=none,%
    captionpos=b,%
    fontadjust=true,%
    columns=[c]fixed,%
    keepspaces=false,%
    basewidth={0.56em, 0.52em},%
    tabsize=2,%
    basicstyle=\small\tt,% \small\tt
    commentstyle=\textit,%
    keywordstyle=\bfseries,%
    escapechar=\%,%
}

%% set latex/pdflatex specific stuff
%\ifpdf
    \usepackage[pdftex,
                hyperindex,
                plainpages=false,
                breaklinks,
                colorlinks,
                citecolor=black,
                filecolor=black,
                linkcolor=black,
                pagecolor=black,
                urlcolor=black]{hyperref}
    \usepackage[pdftex]{graphicx}
    \DeclareGraphicsExtensions{.jpg,.pdf}
    \pdfcatalog {
        /PageMode (/UseNone)
    }
    \usepackage{thumbpdf}
    \usepackage[pdftex]{color}
%\else
%    \usepackage[ps2pdf]{hyperref}
%    \usepackage{graphicx}
%    \DeclareGraphicsExtensions{.eps,.jpg}
%    \usepackage{color}
%\fi

%\setlength{\parindent}{0pt}
%\setlength{\parskip}{5pt}

% verbfilter stuff
\newcommand{\prog}[1]{{\sl #1}}
\newenvironment{program}[1][10.5]
  {\fontsize{#1}{13.6}\tt\begin{tabbing}\hspace*{0.5\parindent}\=\+\kill}
  {\end{tabbing}\noindent}
\newcommand{\blockcomment}[1]{{\color{grayPoint3}#1}}
\newcommand{\linecomment}{\color{grayPoint3}}
\newcommand{\grey}{\color{grey}}

%\newenvironment{program}{\ \ \ \ \begin{minipage}{\textwidth}\renewcommand{\baselinestretch}{1.0}\sl\begin{tabbing}}{\end{tabbing}\end{minipage}}
\newcommand{\vem}{\bfseries}
\newcommand{\quotedstring}[1]{{#1}}
\newcommand{\typename}[1]{{#1}}
\newcommand{\literal}[1]{{#1}}

% comments and notes
\newcommand{\comment}[1]{}
%\newcommand{\note}[1]{{\bf $\clubsuit$ #1 $\spadesuit$}}

% figures
\newcommand{\figurebox}[1]
        {\fbox{\begin{minipage}{\textwidth} #1 \medskip\end{minipage}}}
\newcommand{\twofig}[3]
        {\begin{figure*}[t]#3\ \hrulefill\ 
        \caption{\label{#1}#2}\end{figure*}}
\newcommand{\boxfig}[3]
        {\begin{figure*}\figurebox{#3\caption{\label{#1}#2}}\end{figure*}}
\newcommand{\figref}[1]
        {Figure~\ref{#1}}

% typing rules (not used here)
\newcommand{\ttag}[1]{\mbox{\textsc{\small(#1)}}}
\newcommand{\infer}[3]{\mbox{#1 }\ba{c} #2 \\ \hline #3 \ea}
\newcommand{\irule}[2]{{\renewcommand{\arraystretch}{1.2}\ba{c} #1 
                        \\ \hline #2 \ea}}
\newlength{\trulemargin}
\newlength{\trulewidth}
\newlength{\srulewidth}
\setlength{\trulemargin}{1.75cm}
\setlength{\trulewidth}{83.7mm}
\setlength{\srulewidth}{6.0cm}
\newenvironment{trules}{$\vspace{0.5em}\ba{p{\trulemargin}@{~}p{\trulewidth}@{~}p{\trulemargin}}}{\ea$}
\newenvironment{srules}{$\vspace{0.5em}\ba{p{\trulemargin}@{~}p{\srulewidth}}}{\ea$}
\newcommand{\laxiom}[2]{\ttag{#1} & $ #2 \hfill\ }
\newcommand{\raxiom}[2]{\hfill #2 $& \hfill \ttag{#1}}
\newcommand{\caxiom}[2]{\ttag{#1} & $\hfill #2 \hfill $& \ }
\newcommand{\lrule}[3]{\laxiom{#1}{\irule{#2}{#3}}}
\newcommand{\rrule}[3]{\raxiom{#1}{\irule{#2}{#3}}}
\newcommand{\crule}[3]{\caxiom{#1}{\irule{#2}{#3}}}
\newcommand{\lsrule}[3]{\lsaxiom{#1}{\irule{#2}{#3}}}
\newcommand{\rsrule}[3]{\rsaxiom{#1}{\irule{#2}{#3}}}
\newcommand{\nl}{\end{trules}\\[0.5em] \begin{trules}}
\newcommand{\snl}{\end{srules}\\[0.5em] \begin{srules}}

% commas and semicolons
\newcommand{\comma}{,\,}
\newcommand{\commadots}{\comma \ldots \comma}
\newcommand{\semi}{;\mbox{;};}
\newcommand{\semidots}{\semi \ldots \semi}

% spacing
\newcommand{\gap}{\quad\quad}
\newcommand{\biggap}{\quad\quad\quad}
\newcommand{\nextline}{\\ \\}
\newcommand{\htabwidth}{0.5cm}
\newcommand{\tabwidth}{1cm}
\newcommand{\htab}{\hspace{\htabwidth}}
\newcommand{\tab}{\hspace{\tabwidth}}
\newcommand{\linesep}{\ \hrulefill \ \smallskip}

% math stuff
\newenvironment{myproof}{{\em Proof:}}{$\Box$}
\newenvironment{proofsketch}{{\em Proof Sketch:}}{$\Box$}
\newcommand{\Case}{{\em Case\ }}

% make ; a delimiter in math mode
% \mathcode`\;="8000 % Makes ; active in math mode
% {\catcode`\;=\active \gdef;{\;}}
% \mathchardef\semicolon="003B

% reserved words
\newcommand{\mathem}{\bf}

% brackets
\newcommand{\set}[1]{\{#1\}}
\newcommand{\sbs}[1]{\lquote #1 \rquote}

% arrays
\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}
\newcommand{\bda}{\[\ba}
\newcommand{\eda}{\ea\]}
\newcommand{\ei}{\end{array}}
\newcommand{\bcases}{\left\{\begin{array}{ll}}
\newcommand{\ecases}{\end{array}\right.}

% \cal ids
\renewcommand{\AA}{{\cal A}}
\newcommand{\BB}{{\cal B}}
\newcommand{\CC}{{\cal C}}
\newcommand{\DD}{{\cal D}}
\newcommand{\EE}{{\cal E}}
\newcommand{\FF}{{\cal F}}
\newcommand{\GG}{{\cal G}}
\newcommand{\HH}{{\cal H}}
\newcommand{\II}{{\cal I}}
\newcommand{\JJ}{{\cal J}}
\newcommand{\KK}{{\cal K}}
\newcommand{\LL}{{\cal L}}
\newcommand{\MM}{{\cal M}}
\newcommand{\NN}{{\cal N}}
\newcommand{\OO}{{\cal O}}
\newcommand{\PP}{{\cal P}}
\newcommand{\QQ}{{\cal Q}}
\newcommand{\RR}{{\cal R}}
\newcommand{\TT}{{\cal T}}
\newcommand{\UU}{{\cal U}}
\newcommand{\VV}{{\cal V}}
\newcommand{\WW}{{\cal W}}
\newcommand{\XX}{{\cal X}}
\newcommand{\YY}{{\cal Y}}
\newcommand{\ZZ}{{\cal Z}}

% misc symbols
\newcommand{\dhd}{\!\!\!\!\!\rightarrow}
\newcommand{\Dhd}{\!\!\!\!\!\Rightarrow}
\renewcommand{\ts}{\,\vdash\,}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\eg}{{\em e.g.}}

% misc identifiers
\newcommand{\dom}{\mbox{\sl dom}}
\newcommand{\fn}{\mbox{\sl fn}}
\newcommand{\bn}{\mbox{\sl bn}}
\newcommand{\sig}{\mbox{\sl sig}}
\newcommand{\IF}{\mbox{\mathem if}}
\newcommand{\OTHERWISE}{\mbox{\mathem otherwise}}
\newcommand{\expand}{\prec}
\newcommand{\weakexpand}{\prec^W}
\newcommand{\spcomma}{~,~}

%\newcommand{\inst}{\mbox{\mathem inst}}
\newcommand{\trans}[1]{\la\!\la#1\ra\!\ra}
\renewcommand{\remark}[1]{{\bf $\clubsuit$ #1 $\spadesuit$}}
\newcommand{\todo}[1]{\remark{to do: #1}}
%\newcommand{\J}{\justifies}
%\newcommand{\U}{\using}

% names
\newcommand{\Scala}{\mbox{\textsc{Scala}}}
\newcommand{\Java}{\mbox{\textsc{Java}}}

%\renewcommand\textfraction{.05}
%\renewcommand\floatpagefraction{.9}
%\renewcommand\topfraction{.8}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Language abstraction commands     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Relations
% Subtype 
\newcommand{\sub}{<:}
% Type assignment
\newcommand{\typ}{:}
% reduction
\newcommand{\reduces}{\;\rightarrow\;}
% well-formedness
\newcommand{\wf}{\;\mbox{\textbf{wf}}}

%% Operators
% Type selection
\newcommand{\tsel}{\#}
% Function type
\newcommand{\tfun}{\rightarrow}
\newcommand{\dfun}[3]{(#1\!:\!#2) \Rightarrow #3}
% Conjunction
\newcommand{\tand}{\wedge}
% Disjunction
\newcommand{\tor}{\vee}
% Singleton type suffix
\newcommand{\sing}{.\textbf{type}}

%% Syntax
% Header for typing rules
\newcommand{\judgement}[2]{{\bf #1} \hfill #2}
% Refinement
\newcommand{\refine}[2]{\left\{#1 \Rightarrow #2 \right\}}
% Field definitions
\newcommand{\ldefs}[1]{\left\{#1\right\}}
% Member sequences
\newcommand{\seq}[1]{\overline{#1}}
% Lambda
\newcommand{\dabs}[3]{(#1\!:\!#2)\Rightarrow #3}
\newcommand{\abs}[3]{\lambda #1\!:\!#2.#3}
% Application
\newcommand{\app}[2]{#1\;#2}
% Substitution
\newcommand{\subst}[3]{[#1/#2]#3}
% Object creation
\newcommand{\new}[3]{\textbf{val }#1 = \textbf{new }#2 ;\; #3}
%\renewcommand{\new}[3]{#1 \leftarrow #2 \,\textbf{in}\, #3}
% Field declaration
\newcommand{\Ldecl}[3]{#1 : #2..#3}%{#1 \operatorname{>:} #2 \operatorname{<:} #3}
\newcommand{\ldecl}[2]{#1 : #2}
% Top and Bottom
\newcommand{\Top}{\top}%{\textbf{Top}}
\newcommand{\Bot}{\bot}%\textbf{Bot}}
% Environment extension
%\newcommand{\envplus}[1]{\uplus \{ #1 \}}
\newcommand{\envplus}[1]{, #1}
% Reduction
\newcommand{\reduction}[4]{#1 \operatorname{|} #2 \reduces #3 \operatorname{|} #4}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%% BEGIN DOCUMENT %%%%
%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\thispagestyle{plain}
\pagestyle{plain}
\mainmatter

\title{Dependent Object Types - A foundation for Scala's type system
  \\ \ \\ \large Draft of \today\ -- Do Not Distrubute}
\author{Martin Odersky, Geoffrey Alan Washburn}
\institute{EPFL}

\maketitle
\sloppy
\newcommand{\lindent}{\hspace{-4mm}}

\begin{abstract}
\end{abstract}
\renewcommand{\abs}[3]{\ifdep \dabs #1 #2 #3 \else \lambda #1\!:\!#2.#3 \fi}

%\fontfamily{timesroman}
\section{Introduction}

This paper presents a proposal for a new type-theoretic foundation of
Scala and languages like it. The properties we are interested in
modelling are Scala's path-dependent types and abstract type members,
as well as its mixture of nominal and structural typing through the
use of refinement types. Compared to previous approaches (nuObj, FS),
we make no attempt to model inheritance or mixin composition. Indeed
we will argue that such concepts are better modelled in a different
setting.

The calculus does not precisely describe what's currently in Scala. It
is more normative than descriptive. The main point of deviation
concerns the difference between Scala's compound type formation using
{\bf with} and classical type intersection, as it is modelled in the
calculus. Scala, and the previous calculi attempting to model it
conflates the concepts of compound types (which inherit the members of
several parent types) and mixin composition (which build classes from
other classes and traits). At first glance, this offers an economy of
concepts. However, it is problematic because mixin composition and
intersection types have quite different properties. In the case of
several inherited members with the same name, mixin composition has to
pick one which overrides the others. It uses for that the concept of
linearization of a trait hierarchy. Typically, given two independent
traits $T_1$ and $T_2$ with a common method $m$, the mixin composition
\c@$T_1$ with $T_2$@ would pick the $m$ in $T_2$, whereas the member in
$T_1$ would be available via a super-call. All this makes sense from
an implementation standpoint. From a typing standpoint it is more
awkward, because it breaks commutativity and with it several
monotonicity properties.

In the present calculus, we replace Scala's compound types by
classical intersection types, which are commutative. We also
complement this by classical union types. Intersections and unions
form a lattice wrt subtyping. This addresses another problematic
feature of Scala: In Scala's current type system, least upper bounds
and greatest lower bounds do not always exist. Here is an example:
Given two traits
\begin{lstlisting}
  trait A { type T <: A }
  trait B { type T <: B }
\end{lstlisting}
The greatest lower bound of \c@A@ and \c@B@ is approximated by the
infinite sequence
\begin{lstlisting}
  A with B { type T <: A with B { type T <: A with B { type T < ... }}}
\end{lstlisting}
The limit of this sequence does not exist as a type in Scala.

This is problematic because glbs and lubs play a central role in
Scala's type inference. The absence of universal glbs and lubs makes
type inference more brittle and more unpredictable.

\subsection*{Why No Inheritance?}

In the calculus we made the deliberate choice not to model any form of
inheritance. This is, first and foremost, to keep the calculus simple.
Secondly, there are many different approaches to inheritance and
mixin composition, so that it looks advantageous not to tie the basic
calculus to a specific one. Finally, it seems that the modelization of
inheritance lends itself to a different approach than the basic
calculus. For the latter, we need to prove the standard theorems of
preservation and progress to establish soundness of the type system.
One might try to do this also for a calculus with inheritance, but our
experience suggests that this complicates the proofs considerably.  An
alternative approach to inheritance that might work better is to model
it as a form of code-reuse. Starting with an enriched type system with
inheritance, and a translation to the basic calculus, one needs to
show type preservation wrt the translation. This might be easier than
to prove type preservation wrt reduction.


\section{The DOT Calculus}

\begin{figure}
\figurebox{
%\renewcommand{\baselinestretch}{0.95}
{\bf Syntax}\medskip
    
$\ba{l@{\hspace{2mm}}|@{\hspace{2mm}}l}
\ba[t]{l@{\hspace{10mm}}l}
x, y, z    & \lindent{\mbox{Variable}} \\
l          & \lindent{\mbox{Value label}}\\[0.2em]
v ::=      & \lindent{\mbox{Value}} \\
\gap x     & \mbox{variable} \\
\gap \abs x T t & \mbox{function} \\[0.2em]
t ::=      & \lindent{\mbox{Term}} \\
\gap v     & \mbox{value} \\
\gap \app t t  & \mbox{application} \\
\gap \new x c t & \mbox{new instance} \\
\gap t.l  & \mbox{selection} \\[0.2em]
p ::= & \lindent \mbox{Path} \\
\gap x & \mbox{variable} \\
\gap p.l & \mbox{selection} \\
c ::= T_c \ldefs{\seq{l = v}} & \lindent{\mbox{Constructor}} \\[0.2em]
\Gamma ::= \seq{x \typ T} & \lindent\mbox{Environment} \\
s      ::= \seq{x \mapsto c} & \lindent\mbox{Store} \\
\ea
&
\ba[t]{l@{\hspace{10mm}}l}
L ::=      & \lindent{\mbox{Type label}} \\
\gap L_c   & \mbox{class label} \\
\gap L_a   & \mbox{abstract type label} \\[0.2em]
S,T,U,V  ::= & \lindent\mbox{Type}\\
\gap p.L & \mbox{type selection} \\
\gap T \refine z {\seq D} & \mbox{refinement} \\
\ifdep
  \gap \dfun x T T & \mbox{dependent function type} \\
\else
  \gap T \tfun T & \mbox{function type} \\
\fi
\gap T \tand T & \mbox{intersection type} \\
\gap T \tor T & \mbox{union type} \\
\gap \Top  & \mbox{top type} \\
\gap \Bot  & \mbox{bottom type} \\[0.2em]
S_c, T_c ::= & \lindent \mbox{Concrete type} \\
\multicolumn{2}{l}{\gap p.L_c ~|~ T_c \refine z {\seq D} ~|~ T_c \wedge T_c  ~|~ \Top} \\[0.2em]
D ::= & \lindent\mbox{Declaration} \\
\gap \Ldecl L S U & \mbox{type declaration} \\
\gap \ldecl l T   & \mbox{value declaration}
\ea
\ea$
\medskip

\linesep

\begin{multicols}{2}[\judgement{Reduction}{\fbox{$\reduction t s {t'} {s'}$}}]

\infax[$\beta_v$]
{\reduction {(\app{\abs x T t}){v}} s {\subst v x t} s}

\infrule[\textsc{sel}]
{x \mapsto T_c \ldefs{\seq{l = v}} \in s}
{\reduction {x.l_i} s {v_i} s}

\infax[\textsc{new}]
{\reduction {\new x c t} s t {s \envplus{x \mapsto c}}}

\infrule[\textsc{context}]
{\reduction t s {t'} {s'}}
{\reduction {e[t]} s {e[t']} s'}
\end{multicols}

\hfill {\bf where} evaluation context $\gap e ::= [\,] ~|~ \app e t ~|~ \app v e ~|~ e.l\hspace{2cm}$

\linesep

\begin{multicols}{2}[\judgement{Type Assignment}{\fbox{$\Gamma \ts t \typ T$}}]

\infrule[\textsc{var}]
{x \typ T \in \Gamma}
{\Gamma \ts x \typ T}

\ifdep
  \infrule[\textsc{app-term}]
  {x \not\in \fn(T) \\
  \Gamma \ts t \typ \dfun x {T'} T \spcomma t' \typ T'}
  {\Gamma \ts \app t {t'} \typ T}

  \infrule[\textsc{app-path}]
  {\Gamma \ts t \typ \dfun x {T'} T \spcomma p \typ T'}
  {\Gamma \ts \app t p \typ \subst p x T}

  \infrule[\textsc{abs}]
  {\Gamma \envplus{x \typ S} \ts t: T \\
   \Gamma \ts S \wf \spcomma \dfun x S T \sub T' \spcomma T' \wf}
  {\Gamma \ts \abs x S t \typ T'}
\else
  \infrule[\textsc{app}]
  {\Gamma \ts t \typ  S \tfun T \spcomma t' \typ T' \spcomma T' \sub S}
  {\Gamma \ts \app t {t'} \typ T}

  \infrule[\textsc{abs}]
  {x \notin \fn(T) \andalso \Gamma \ts S \wf \\
  \Gamma \envplus{x \typ S} \ts t: T}
  {\Gamma \ts \abs x S t \typ S \tfun T}
\fi

\infrule[\textsc{sel}]
{\Gamma \ts t \ni l \typ T'}
{\Gamma \ts t.l \typ T'}

\infrule[\textsc{new}]
{x \notin \fn(T') \\
\Gamma \ts T_c \wf \spcomma T_c \expand_x \seq{\Ldecl L S U},\seq{\ldecl l V} \\
 \Gamma \envplus{x: T_c} \ts \seq{S \sub U} \spcomma \seq{v \typ V'}
 \spcomma \seq{V' \sub V} \spcomma t \typ T'}
{\Gamma \ts \new x {T_c \ldefs{\seq{l = v}}} t \typ T'}

%\infrule[\textsc{sub}]
%{\Gamma \ts t: T \spcomma T \sub T'}
%{\Gamma \ts t: T'}

\end{multicols}

}

\caption{The DOT Calculus : Syntax, Reduction, Type Assignment}\label{dot-one}
\end{figure}

The DOT calculus is a simple system of dependent
object-types. Figure~\ref{dot-one} gives its syntax, reduction rules,
and type assignment rules.

\subsection*{Notation} We use standard notational conventions for
sets. The notation $\seq{X}$ denotes a set of elements $X$. Given a
such a set $\seq X$ in a typing rule, $X_i$ denotes an arbitrary
element of $X$. 
The $\uplus$ operator extends a set of bindings. It is required that the added binding does not
introduce a variable which is already bound in the base-set. 
We use an
abbreviation for preconditions in typing judgements. Given an
environment $\Gamma$ and some predicates $P$ and $Q$, the condition $\Gamma \ts P \spcomma Q$
is a shorthand for the two conditions $\Gamma \ts P$ and $\Gamma \ts Q$.

\subsection*{Syntax}

There are three alphabets: Variable names $x$, $y$, $z$ are freely
alpha-renamable. They occur as parameters of lambda abstractions, as
binders for objects created by \verb@new@-expressions, and as self
references in refinements. Value labels $l$ denote fields in objects,
which are bound to values at run-time. Type labels $L$ denote type
members of objects. Type labels are further separated into labels for
abstract types $L_a$ and labels for classes $L_c$. It is assumed that
in each program every class label $L_c$ is declared at most once.

We assume that the label alphabets $l$ and $L$ are finite. This is
not a restriction in practice, because one can include in these 
alphabets every label occurring in a given program.

The terms $t$ in DOT consist of variables $x$, $y$, $z$, lambda
abstractions $\abs x T t$, function applications $\app t {t'}$, field
selections $t.l$, and object creation expressions $\new x c t$ where
$c$ is a constructor $T_c \ldefs{\seq{l = v}}$. The latter binds a
variable $x$ to a new instance of type $T_c$ with fields $\seq l$ initialized to values $\seq v$.  The scope of $x$ extends through the term $t$.

Two subclasses of terms are values $v$, which consist of just
variables and lambda abstractions, and paths $v$ which consist of just
variables and selections.

The types in DOT are denoted by letters $S$, $T$, $U$, or $V$. They consist of the following:
\begin{itemize}
\item[-] Type selections $p.L$, which denote the type member $L$ of path $p$.
%         A shorthand notation applies to type selections on singleton types: Instead
%         of $p \sing \tsel L$ one can write just $p.L$.
\item[-] Refinement types $T \refine z {\seq D}$, which refine a type $T$ by a set of declarations $D$.
         The variable $z$ refers to the ``self''-reference of the type. Declarations can refer to
         other declarations in the same type by selecting from $z$.
\ifdep
  \item[-] Dependent function types $\dfun x T {T'}$.
\else
  \item[-] Function types $T \tfun T'$.
\fi
\item[-] Type intersections $T \tand T'$, which carry the declarations of members present in either $T$ or $T'$.
\item[-] Type unions $T \tor T'$, which carry only the declarations of members present in both $T$ and $T'$.
\item[-] A top type $\Top$, which corresponds to an empty object.
\item[-] A bottom type $\Bot$, which represents a non-terminating computation.
\end{itemize}
A subset of types $T_c$ are called {\em concrete types}. These are type selections
$p.L_c$ of class labels,
the top type $\Top$, intersections of concrete types, and refinements $T_c \refine z {\seq D}$ of concrete types. Only concrete types are allowed in constructors $c$.

%Types in DOT form a lattice where $\tand$ is join and $\tor$ is meet. 

There are only two forms of declarations in DOT, which are both part
of refinement types.  A value declaration $\ldecl l T$ introduces a
field with type $T$.  A type declaration $\Ldecl L S U$ introduces a
type member $L$ with a lower bound type $S$ and an upper bound type
$U$. There are no type aliases, but a type alias can be simulated by a
type declaration $\Ldecl L T T$ where the lower bound and the upper
bound are the same type $T$. 

%It is assumed that the lower bound of
%every class type is the bottom type and that the upper bound is a
%concrete type. That is, the only permissible form of a class
%declaration is $\Ldecl {L_c} \Bot T_c$.

Every field or type label can be declared only once in a set of
declarations $\seq D$. A set of declarations can hence be seen as a map from
labels to their declarations.  Meets $\wedge$ and joins $\vee$ on sets of
declarations are defined as follows.  

\bda{lcl@{\gap}l}
    
      \dom(\seq D \tand \seq {D'}) &~=~& \dom(\seq{D}) \cup \dom(\seq{D'}) \\
      \dom(\seq D \tor \seq {D'}) &=& \dom(\seq{D}) \cap \dom(\seq{D'}) \\[0.5em]
      (D \tand D')(L) &=&
        \Ldecl L {(S \tor S')} {(U \tand U')} & \mbox{if~} (\Ldecl L S U) \in \seq{D} \;\mbox{and}\; (\Ldecl L {S'} {U'}) \in \seq{D'} \\
        &=& D(L) & \mbox{if~} L \notin \dom(\seq{D'}) \\
        &=& D'(L) & \mbox{if~} L \notin \dom(\seq{D}) \\
      (D \tand D')(l) &=&
        \ldecl l {T \tand T'} & \mbox{if~} (\ldecl l T) \in \seq{D} \;\mbox{and}\; (\ldecl l {T'}) \in \seq{D'} \\
        &=& D(l) & \mbox{if~} l \notin \dom(\seq{D'}) \\
        &=& D'(l) & \mbox{if~} l \notin \dom(\seq{D}) \\[0.5em]
      (D \tor D')(L) &=&
        \Ldecl L {(S \tand S')} {(U \tor U')} & \mbox{if~} (\Ldecl L S U) \in \seq{D} \;\mbox{and}\; (\Ldecl L {S'} {U'}) \in \seq{D'} \\
      (D \tor D')(l) &=&
        \ldecl l {T \tor T'} & \mbox{if~} (\ldecl l T) \in \seq{D} \;\mbox{and}\; (\ldecl l {T'}) \in \seq{D'} 
    \eda

Sets of declarations form a lattice with the given meet $\wedge$ and
join $\vee$, the empty set of declatations as the top element, and
the bottom element $\seq{D_\Bot}$, Here $\seq{D_\Bot}$ is the set of
declarations that contains for every term label $l$ the
declaration $\ldecl l \Bot$ and for every type label $L$ the
declaration $\Ldecl L \Top \Bot$. 



\subsection*{Reduction rules}

Reduction rules $\reduction t s {t'} {s'}$ in DOT rewrite pairs of
terms $t$ and stores $s$, where stores map variables to constructors.
There are three main reduction rules: ($\beta_V$) is the standard beta
reduction of call-by-value lambda calculus. Rule (\textsc{new}) rewrites an
object creation $\new x c t$ by placing the binding of variable $x$ 
to constructor $c$ in the store and continuing with term $t$. Rule (\textsc{sel})
rewrites a field selection $x.l$ by retrieving the corresponding value from the store.
These reduction rules can be applied anywhere in a term where the hole $[\,]$ of 
an evaluation context $e$ can be situated. 

\subsection*{Type assignment rules}

The last part of Figure~\ref{dot-one} presents rules for type
assignment.  
\ifdep
The four rules (\textsc{var}), (\textsc{abs}), (\textsc{app-term}) and
(\textsc{app-path}) correspond to dependently typed lambda calculus
with a subtyping discipline. There are two rules for
applications. Rule (\textsc{app-term}) implements the standard
application rule if the function's result type does not depend on its
argument type. Rule (\textsc{app-path}) applies to dependently typed
functions which can only be applied to paths.
Instead of adding a separate subsumption rule,
subtyping is expressed by preconditions in the application rules and
also in rule (\textsc{new}).  
\else
The three rules (\textsc{var}), (\textsc{abs}), and
(\textsc{app}) on the left correspond to simply typed lambda calculus
with a subtyping discipline (I believe it is straightforward to extend
this to full $F_{\sub}$). Rule (\textsc{abs}) has an additional precondition
stating that the bound variable $x$ may not appear in the function's
result type $T'$. It would be an interesting extension of the calculus
to drop this precondition, thereby allowing dependent function types.
Instead of adding a separate subsumption rule,
subtyping is expressed by preconditions in rules (\textsc{app}) and
(\textsc{new}).  
\fi
Rule rule (\textsc{sub}) is the standard subsumption rule for subtyping.

%The (\textsc{path}) rule gives the alternate type $p \sing$ to a well-typed path
%$p$ whose type $T$ has a non-empty expansion $D,\seq{D}$.  By the subtyping rule
%(\textsc{single-$\sub$}) in Figure~\ref{dot-sub}, the alternate type $p \sing$
%is guaranteed to be a subtype of the underlying type $T$ of $p$.

Rule (\textsc{sel}) types a field selection by means of an auxiliary
membership relation $\ni$, which determines whether a given term contains a given
declaration as one of its members. The membership relation is defined in
Figure~\ref{dot-two} and is further explained below.

The last rule, (\textsc{new}), assigns types to object creation
expressions. It is the most complex of DOT's typing rules.  To
type-check an object creation $\new x {T_c \ldefs {\seq{l = v}}} t$,
one verifies first that the type $T_c$ is well-formed (see
Figure~\ref{dot-wf} for a definition of well-formedness).  One then
determines the set of all declarations that this type carries, using
the expansion relation $\expand$ defined in Figure~\ref{dot-two}.
Every type declaration $\Ldecl L S U$ in this set must be realizable,
i.e.\ its lower bound $S$ must be a subtype of its upper bound $U$.
Every field declaration $\ldecl l V$ in this set must have a
corresponding initializing value of $v$ of type $V$.  These checks are
made in an environment which is extended by the binding $x: T_c$. In
particular this allows field values that recurse on ``self'' by
referring to the bound variable $x$. As in the (\textsc{abs}) rule, it
is required that the bound variable does not appear in the
expression's result type $T'$.

\begin{figure}
 \figurebox{

    \begin{multicols}{2}[\judgement{Membership}{\fbox{$\Gamma \ts t \ni D$}}]

      \infrule[\textsc{path-$\ni$}]
      {\Gamma \ts p \typ T \spcomma T \expand_z \seq D}
      {\Gamma \ts p \ni \subst p z {D_i}}

      \infrule[\textsc{term-$\ni$}]
      {z \not\in \fn(D_i) \andalso \Gamma \ts t \typ T \spcomma T \expand_z \seq D}
      {\Gamma \ts t \ni D_i}
   \end{multicols}

   \linesep

    \begin{multicols}{2}[\judgement{Expansion}{\fbox{$\Gamma \ts T_c \expand_z \seq D$}}]  

      \infrule[\textsc{rfn-$\expand$}]
      {\Gamma \ts T \expand_z {\seq D'}}
      {\Gamma \ts T \refine z {\seq D} \expand_z \seq {D'} \tand \seq D}

      \infrule[\textsc{$\tand$-$\expand$}]
      {\Gamma \ts T_1 \expand_z {\seq D_1} \spcomma T_2 \expand_z {\seq D_2}}
      {\Gamma \ts T_1 \tand T_2 \expand_x {\seq D_1 \tand \seq D_2}}

      \infax[\textsc{$\Top$-$\expand$}]
      {\Gamma \ts \Top \expand_z \{\}}

      \infax[\textsc{$\tfun$-$\expand$}]
      {\Gamma \ts S \tfun T  \expand_z \{\}}

      \infrule[\textsc{tsel-$\expand$}]
      {\Gamma \ts p \ni \Ldecl L S U \spcomma U \expand_z \seq D}
      {\Gamma \ts p.L \expand_z \seq D}

      \infrule[\textsc{$\tor$-$\expand$}]
      {\Gamma \ts T_1 \expand_z {\seq D_1} \spcomma T_2 \expand_z {\seq D_2}}
      {\Gamma \ts T_1 \tor T_2 \expand_x {\seq D_1 \tor \seq D_2}}

      \infax[\textsc{$\Bot$-$\expand$}]
      {\Gamma \ts \Bot \expand_z \seq{D_\Bot}}
    \end{multicols}

}
\caption{The DOT Calculus : Membership and Expansion}\label{dot-two}
\end{figure}


\subsection*{Membership}

Figure~\ref{dot-two} presents typing rules for membership and
expansion.  The membership judgement $\Gamma \ts t \ni D$ states that
in environment $\Gamma$ a term $t$ has a declaration $D$ as a member.
There are different rules for paths and general terms.  Rule
(\textsc{path-$\ni$}) applies to paths $p$ that have a refinement type
$T \refine z {\seq D}$ as their type. Members of $p$ are then all
definitions $D$ in the refinement, where any use of the self reference
$z$ is replaced by the path $p$ itself.  Rule (\textsc{and-$\ni$})
allows to merge two member definitions (of the same label) by
conjoining them with $\tand$. Rule (\textsc{term-$\ni$}) establishes
the members of general terms $t$ of type $T$ by introducing a dummy
variable $z$ of type $T$ and then using the rules for path membership
on $z$. It must hold that $z$ itself does not form part of the
resulting member $D$.

\subsection*{Expansion}
      
The expansion relation $\expand$ is needed to typecheck the complete
set of declarations carried by a concrete type that is used in a
\textbf{new}-expression.  Since this is the only place where expansion
is needed, it is sufficient to define it on concrete types only. The
bottom part of Figure~\ref{dot-two} gives the typing rules for
expansion.

Rule (\textsc{rfn-$\expand$}) states that a refinement type $T_c
\expand_z {\seq D}$ expands to the conjunction of the expansion $D'$
of $T_c$ and the newly added declarations $D$. Rule
(\textsc{tsel-$\expand$}) states that a type selection $p.L$ carries
the same declarations as the upper bound $U$ of $L$ in $T$.  Rule
($\tand$-$\expand$) states that expansion distributes through meets.
Rule (\textsc{$\top$-$\expand$}) states that the top type $\top$
expands to the empty set.

\begin{figure}
  \figurebox{

    \begin{multicols}{2}[\judgement{Subtyping}{\fbox{$\Gamma \ts S \sub T$}}]

%      \infrule[\textsc{trans}]
%      {\Gamma \ts S \sub T \spcomma T \sub U}
%      {\Gamma \ts S \sub U}

      \infax[\textsc{refl}]
      {\Gamma \ts T \sub T}

      \infrule[\textsc{$\sub$-rfn}]
      {\Gamma \ts S \sub T \spcomma S \expand_z \seq{D'} \spcomma \seq{D' \sub D}}
      {\Gamma \ts S \sub T \refine z {\seq D}}

      \infrule[\textsc{$\sub$-tsel}]
      {\Gamma \ts p \ni \Ldecl L S U \spcomma S \sub U \spcomma S' \sub S }
      {\Gamma \ts S' \sub p.L}

      \infrule[\textsc{$\sub$-$\tand$}]
      {\Gamma \ts T \sub T_1 \spcomma T \sub T_2}
      {\Gamma \ts T \sub T_1 \tand T_2}

      \infrule[\textsc{$\sub$-$\tor$}]
      {\Gamma \ts T \sub T_i}
      {\Gamma \ts T \sub T_1 \tor T_2}
      
      \infax[\textsc{$\sub$-$\Top$}]
      {\Gamma \ts T \sub \Top}
      
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ifdep
      \infrule[\textsc{$\sub$-$\Rightarrow$}]
      {\Gamma \ts T \sub S \\ \Gamma \envplus {x: S} \ts S' \sub T'}
      {\Gamma \ts \dfun x S {S'} \sub \dfun x T {T'}}
\else
      \infrule[\textsc{$\sub$-$\tfun$}]
      {\Gamma \ts T \sub S \spcomma S' \sub T'}
      {\Gamma \ts S \tfun S' \sub T \tfun T'}
\fi
      \infrule[\textsc{rfn-$\sub$}]
      {\Gamma \ts T \sub T'}
      {\Gamma \ts T \refine z {\seq D} \sub T'}

      \infrule[\textsc{tsel-$\sub$}]
      {\Gamma \ts p \ni \Ldecl L S U \spcomma S \sub U \spcomma U \sub U'}
      {\Gamma \ts p.L \sub U'}

      \infrule[\textsc{$\tand$-$\sub$}]
      {\Gamma \ts T_i \sub T}
      {\Gamma \ts T_1 \tand T_2 \sub T}

      \infrule[\textsc{$\tor$-$\sub$}]
      {\Gamma \ts T_1 \sub T \spcomma T_2 \sub T}
      {\Gamma \ts T_1 \tor T_2 \sub T}

      \infax[\textsc{$\Bot$-$\sub$}]
      {\Gamma \ts \Bot \sub T}

      \end{multicols}

    \linesep

    \begin{multicols}{2}[\judgement{Declaration subsumption}{\fbox{$\Gamma \ts D \sub D'$}}]

    \infrule[\textsc{tdecl-$\sub$}]
            {\Gamma \ts S' \sub S \spcomma T \sub T'}
            {\Gamma \ts (\Ldecl L S T) \sub (\Ldecl L {S'} {T'})}

    \infrule[\textsc{vdecl-$\sub$}]
            {\Gamma \ts T \sub T'}
            {\Gamma \ts (\ldecl l T) \sub (\ldecl l {T'})}

    \end{multicols}
  }
\caption{The DOT Calculus : Subtyping and Declaration Subsumption}\label{dot-sub}
\end{figure}


\subsection*{Subtyping}

Figure~\ref{dot-sub} defines the subtyping judgement $\Gamma \ts S
\sub T$ which states that in environment $\Gamma$ type $S$ is a
subtype of type $T$.  Any term of type $S$ can then be regarded via
the subsumption rule (\textsc{sub}) as a term of type $T$.

As usual, subtyping is reflexive (\textsc{refl}) but a corresponding
rule for transitivity is missing.  However, most of the rules for
specific types in Figure~\ref{dot-sub} have transitivity built in. The
issue of transitivity is further discussed below.

To prove that a type $S$ is a subtype of a refinement type $T \refine
z {\seq D}$, it must hold that $S$ is a subtype of $T$ and that $S$
contains declarations that subsume the declarations $\seq D$
(\textsc{$\sub$-rfn}). The refinement type itself is a subtype of its
parent type $T$ and all its supertypes (\textsc{rfn-$\sub$}).

A type selection $p.L$ is a subtype of (all supertypes of) the upper bound $U$ of
$L$ in $p$ (\textsc{tsel-$\sub$}).
It is a supertype of (all subtypes of) its lower
bound $S$ (\textsc{$\sub$-tsel}).  Function types are subject to the
standard co-/contravariant subtyping rule 
\ifdep
 (\textsc{$\sub$-$\Rightarrow$}).
\else
  (\textsc{$\sub$-$\tfun$}).
\fi
%A singleton type $p\sing$ is a subtype of any underlying type of path
%$p$ (\textsc{single-$\sub$}). 
The final six rules in
Figure~\ref{dot-sub} turn the subtyping relation into a lattice with 
meets $\tand$, joins $\tor$, bottom element $\Bot$ and top element $\Top$.

One interesting aspect of the subtyping relation of DOT is that it is
reflexive (\textsc{refl}) but not transitive. Instead of a separate
rule that specifies global transitivity, we find transitivity encoded
in most of the inference rules of Figure~\ref{dot-sub}. There is only
a single situation where transitivity does not hold:  Given a type
declaration $\Ldecl L S U$ which is a member of some type $T$, and a
variable $x$ of type $T$, we have that $S \sub x.L$ by
(\textsc{$\sub$-tsel}) and $x.L \sub U$ by (\textsc{tsel-$\sub$}).
However, this does not imply that $S \sub U$. In fact, 
$T$ might be an {\em unrealizable} type, which admits no solution for
its $L$ member, precisely because the lower bound of $L$ is not a
subtype of its upper bound.

The type assignment rule (\textsc{new}) in Figure~\ref{dot-one}
has as one of its preconditions that the type of
the created object must be realizable: each lower bounds must be a subtype
of its corresponding upper bound. Subtyping can be shown to be transitive in DOT if the
least type of a subtype chain is realizable.


\begin{figure}
  \figurebox{
       \begin{multicols}{2}[\judgement{Well-formed types}{\fbox{$\Gamma \ts T \wf$}}]

      \infrule[\textsc{rfn-wf}]
      {\Gamma \ts T \wf \\ 
       \Gamma \envplus {z: T \refine z {\seq D}} \ts \seq {D \wf}}
      {\Gamma \ts T \refine z {\seq D} \wf}

      \infrule[\textsc{tsel-wf$_1$}]
      {\Gamma \ts p \ni \Ldecl L S U \spcomma S \wf \spcomma U \wf}
      {\Gamma \ts p.L \wf}

      \infrule[\textsc{$\tand$-wf}]
      {\Gamma \ts T \wf \spcomma T' \wf}
      {\Gamma \ts T \tand T' \wf}

      \infax[\textsc{$\Bot$-wf}]
      {\Gamma \ts \Bot \wf}

      %%%%%%%%%%%%%%%%%%%%%%%%%%%

\ifdep
      \infrule[\textsc{$\Rightarrow$-wf}]
      {\Gamma \ts T \wf \\ \Gamma \envplus{x: T} \ts T' \wf}
      {\Gamma \ts \dfun x T {T'} \wf}
\else
      \infrule[\textsc{$\tfun$-wf}]
      {\Gamma \ts T \wf \spcomma T' \wf}
      {\Gamma \ts T \tfun T' \wf}
\fi
      \infrule[\textsc{tsel-wf$_2$}]
      {\Gamma \ts p \ni \Ldecl L \Bot U}
      {\Gamma \ts p.L \wf}

      \infrule[\textsc{$\tor$-wf}]
      {\Gamma \ts T \wf \spcomma T' \wf}
      {\Gamma \ts T \tor T' \wf}

      \infax[\textsc{$\Top$-wf}]
      {\Gamma \ts \Top \wf}
      
    \end{multicols}

    \linesep

    \begin{multicols}{2}[\judgement{Well-formed declarations}{\fbox{$\Gamma \ts D \wf$}}]
      \infrule[\textsc{tdecl-wf}]
      {\Gamma \ts S \wf \spcomma U \wf}
      {\Gamma \ts \Ldecl L S U \wf}

      \infrule[\textsc{vdecl-wf}]
      {\Gamma \ts T \wf}
      {\Gamma \ts \ldecl l T \wf}

    \end{multicols}
  }

\caption{The DOT Calculus : Well-Formedness}\label{dot-wf}
\end{figure}


\subsection*{Declaration Subsumption}

The declaration subsumption judgement $\Gamma \ts D \sub D'$ in Figure~\ref{dot-sub}
states that in environment $\Gamma$
the declaration $D$ subsumes the declaration $D'$. There are two
rules, one for type declarations and one for value declarations. 
Rule (\textsc{tdecl-$\sub$})
states that a type declaration $\Ldecl L S U$ subsumes another type declaration $\Ldecl L {S'} {U'}$
if $S'$ is a subtype of $S$ and $U$ is a subtype of $U'$. In other words, the set of types
between $S$ and $U$ is contained in the set of types between $S'$ and $U'$.
Rule (\textsc{vdecl-$\sub$})
states that a value declaration $\ldecl l T$ subsumes another value declaration $\ldecl l T'$
if $T$ is a subtype of $T'$.

%Declaration subsumption is extended a binary relation between sequences of
%declarations as follows: $\seq{D} <: \seq{D'}$ iff $\forall D'_i \exists D_j. D_j \sub D'_i$.

\subsection*{Well-formedness}

The well-formedness judgement $\Gamma \ts T \wf$ in Figure~\ref{dot-wf}
states that in environment $\Gamma$ the type $T$ is well-formed.

%A singleton type $p \sing$ is well-formed if the path $p$ is
%well-typed (\textsc{single-wf}).  

A refinement type $T \refine z {\seq D}$ is
well-formed if the parent type $T$ is well-formed and every
declaration in $\seq D$ is well-formed in an environment augmented by
the binding of the self-reference $z$ to the refinement type itself
(\textsc{rfn-wf}).

A type selection $p.L$ is
well-formed if $L$ is a member of $p$, and the lower bound of $L$
is also well-formed (\textsc{tsel-wf}). The latter condition
has the effect that the lower bound of a type $p.L$ may not
refer directly or indirectly to a type containing $p.L$ itself
--- if it would, the well-formedness judgement of $p.L$ would
not have a finite proof. No such restriction exists for the upper
bound of $L$. The upper bound may in fact refer back to the
type. Hence, recursive class types and F-bounded abstract types are
both expressible. 

The other forms of types in DOT are all well-formed if their
constituent types are well-formed.

Well-formedness extends straightforwardly to
declarations with the judgement $\Gamma \ts D \wf$. All declarations are well-formed if their constituent types
are well-formed.

\end{document}

\section{Program Examples}

\begin{figure}
 \figurebox{\renewcommand{\baselinestretch}{0.6}
\begin{lstlisting}
val root = new Any { rootThis =>
  trait Unit extends Any {}
  val unit: Any => rootThis.Unit
  trait Boolean extends Any {
    val ifNat: (rootThis.Unit => rootThis.Nat) => (rootThis.Unit => rootThis.Nat) => rootThis.Nat
  }
  val false: rootThis.Unit => rootThis.Boolean
  val true: rootThis.Unit => rootThis.Boolean
  trait Nat extends Any {
    val isZero: rootThis.Unit => rootThis.Boolean
    val pred: rootThis.Unit => rootThis.Nat
    val succ: rootThis.Unit => rootThis.Nat
    val add: rootThis.Nat => rootThis.Nat
  }  
  val zero: rootThis.Unit => rootThis.Nat
  val successor: rootThis.Nat => rootThis.Nat
  val add2: rootThis.Nat => rootThis.Nat => rootThis.Nat
  val error: rootThis.Unit => Bot
} {
  val unit = (x: Any) => val u = new root.Unit; u
  val false = (u: root.Unit) => {
    val ff = new root.Boolean {
      val ifNat = (t: root.Unit => root.Nat) => (e: root.Unit => root.Nat) => e(root.unit)
    }
    ff
  }
  val true = (u: root.Unit) => {
    val tt = new root.Boolean {
      val ifNat = (t: root.Unit => root.Nat) => (e: root.Unit => root.Nat) => t(root.unit)
    }
    tt
  }
  val zero = (u: root.Unit) => {
    val zz = new root.Nat { 
      val isZero = (u: root.Unit) => root.false(root.unit)
      val succ = (u: root.Unit) => root.successor(zz)
      val pred = (u: root.Unit) => error(root.unit)
      val add = (other: root.Nat) => add2(other, zz)
    }
    zz
  }
  val successor = (n: root.Nat) => {
    val ss = new root.Nat {
      val isZero = (u: root.Unit) => root.true(root.unit)
      val succ = (u: root.Unit) => root.successor(ss)
      val pred = (u: root.Unit) => n
      val add = (other: root.Nat) => add2(other, ss)
    }
    ss
  }
  val add2 = (n1: root.Nat) => (n2: root.Nat) =>
    n1.isZero(root.unit).ifNat
     ((u: root.Unit) => n2)
     ((u: root.Unit) => root.add2(n1.pred(root.unit))(n2.succ(root.unit)))
  val error = (u: root.Unit) => error(x)
}
\end{lstlisting}
}
\caption{Some root classes}\label{code:root}
\end{figure}


\begin{figure}
 \figurebox{
\begin{lstlisting}
val genLists = new Any {  
  trait ListPackage extends Any { thisListPackage =>
    type Elem
    type ListOfElem = List { type Elem = thisList.Elem }
    trait List extends Any {
      val isEmpty: root.Unit => root.Boolean
      val head: root.Unit => root.Boolean
      val tail: root.Unit => thisListPackage.ListOfElem
      val prepend: Elem => ListOfElem
    }
    val nil: root.Unit => ListOfElem
    val cons: Elem => ListOfElem => ListOfElem
  }
}
val natLists = new ListPackage { 
  type Elem = Nat
} {
  val nil = (u: root.Unit) => {
    val nn = new natLists.List {
      val isEmpty = (u: root.Unit) => root.true(root.unit)
      val head = (u: root.Unit) => root.error(root.unit)
      val tail = (u: root.Unit) => root.error(root.unit)
      val prepend = (x: root.Nat) => natLists.cons(x, nn)
    }
    nn
  }
  val cons = (x: natLists.Elem) => (xs: natLists.ListOfElem) => {
    val cc = new natLists.List {
      val isEmpty = (u: root.Unit) => root.false(root.unit)
      val head = (u: root.Unit) => x
      val tail = (u: root.Unit) => xs
      val prepend = (x: root.Nat) => natLists.cons(x, cc)
    }
    cc
  }
}
\end{lstlisting}
}
\caption{List classes}\label{code:more}
\end{figure}

\end{document}
