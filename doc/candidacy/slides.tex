\documentclass{beamer}

\usepackage{minted}
\usemintedstyle{eclipse}

\title{Dependent Object Types}
\subtitle{EDIC Candidacy Exam}
\author{Nada Amin}
\institute{LAMP, I\&C, EPFL}
\date{September 12, 2012}

\begin{document}

\frame{\titlepage}

\section{Introduction}

\begin{frame}
\frametitle{DOT: Dependent Object Types}

The DOT calculus proposes a new \emph{type-theoretic foundation} for Scala
and languages like it. It models
\begin{itemize}
\item \emph{path-dependent types}
\item abstract type members
\item mixture of nominal and structural typing via refinement types
\end{itemize}

It does not model
\begin{itemize}
\item inheritance and mixin composition
\item what's currently in Scala
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Path-dependent types}

\begin{description}[path-dependent type]
\item[path-dependent type] limited form of \emph{dependent type}, in which a type depends on a \emph{path}
\item[dependent type] a type which depends on a term
\item[path] a chain of immutable fields or stable values
\end{description}

\inputminted[frame=lines,fontsize=\footnotesize]{scala}{intro.scala}
\end{frame}

\begin{frame}{Selected Papers}
\begin{enumerate}
\item {\it A Type-Theoretic Approach to Higher-Order
  Modules with Sharing}\\{\footnotesize\textcolor{gray}{by Robert Harper and Mark
  Lillibridge}}\begin{itemize}
\item calculus for modules in the ML tradition
\item modules are first-class values
\end{itemize}
\item {\it Tribe: a simple virtual class calculus}\\
  {\footnotesize\textcolor{gray}{by Dave Clarke, Sophia Drossopoulou, James Noble and Tobias Wrigstad}}\begin{itemize}
\item calculus for virtual classes
\item paths are types, and types are ``generalized'' paths
\end{itemize}
\item {\it A Nominal Theory of Objects with Dependent
  Types}\\{\footnotesize\textcolor{gray}{by Martin Odersky, Vincent Cremet, Christine R{\"o}ckl and
  Matthias Zenger}}\begin{itemize}
\item calculus unifying advanced object-oriented and module systems
\item foundation for Scala
\end{itemize}
\end{enumerate}
\end{frame}

\section{Survey of Selected Papers}

\subsection{``Translucent'' ML}

\begin{frame}{SML modules}
\begin{description}[structure]
\item[structure] a module; a collection of types, values and
  (sub)structures packaged as a program unit.
\item[signature] an interface; the type of a structure; description of
  the types, values and (sub)structures of a structure given by their
  kinds, types and interfaces.
\item[functor] a function mapping structures to structures
\item[type-sharing] enables stating that types specified in separate
  modules are actually equal
\end{description}
% example?
\end{frame}

\begin{frame}{Limitations of SML modules}
\begin{itemize}
\item modules are not first-class; e.g. not possible to return a
  structure from an {\tt if} expression.
\item type sharing is restricted to equality between type names, not
  general type expressions; in effect, transparency / opaqueness of a
  signature cannot be fully fined-tuned
\end{itemize}
\end{frame}

\begin{frame}{Translucent Sums}
\begin{itemize}
\item values representing modules
\item translucent sum: sequence of bindings; translucent sum type:
  sequence of declarations
\item differs from traditional records, because later fields can
  depend on earlier ones
\item allows any type to be partially or fully deermined by a type
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Example}
\begin{minted}{sml}
structure XInt = struct
  type T = int
  val v = 3
  val f = negate
end
structure XBool = struct
  type T = bool
  val v = true
  val f = not
end
structure X =
  if flip() then XInt else XBool
signature XType = sig
  type T
  val v = T
  val f = T -> T
end
\end{minted}
\end{frame}

% Maintaing Soundness?

\begin{frame}{Path-Dependent Types}
\begin{itemize}
\item Scala's abstract types have close resemblances to abstract types
  of signatures in these ML-like module systems. In particular, in
  their calculus, there's a form of dependent type, since translucent
  sums are terms that may contain types.
\item More concretely, their so-called VALUE rules enable a
  translucent sum to be given a more precise type by referring to the
  names of its type members with a path selection -- this ability
  based on path-dependent types is not only essential for breaking the
  dependencies between (sub)fields but also critical for the
  propagation of typing information.
\item Compared to Scala, these path-dependent types are more limited
  because recursive references and bounded quantifications are not
  allowed.
\end{itemize}
\end{frame}

\subsection{Tribe Calculus}
% Virtual Classes
% Example
% Tribe Types (generalized paths & subtyping relation)
% Follow-up
  % Ownership System?
  % Soundness?
  % Cross-Family Inheritance

\subsection{${\nu}Obj$}

\section{Proposal}

\begin{frame}[fragile]{Hello}
\begin{minted}{scala}
object HelloWorld extends App {
  println("Hello, World")
}
\end{minted}
\end{frame}

\section{Backup Slides}

% System F omega
% System F sub
\end{document}
