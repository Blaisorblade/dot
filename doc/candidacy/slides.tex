\documentclass{beamer}

\input{macros}
\input{nuobj}

\usepackage{minted}
\usemintedstyle{eclipse}


\useoutertheme{infolines}
\setbeamertemplate{headline}{}
\setbeamertemplate{footline}{
  \hfill
  \usebeamercolor[fg]{page number in head/foot}
  \usebeamerfont{page number in head/foot}
  \insertpagenumber\kern1em\vskip2pt
}
\setbeamertemplate{navigation symbols}{}


\title{Dependent Object Types}
\subtitle{EDIC Candidacy Exam}
\author{Nada Amin}
\institute{LAMP, I\&C, EPFL}
\date{September 12, 2012}

\begin{document}

\frame{\titlepage}

\section{Introduction}

\begin{frame}
\frametitle{DOT: Dependent Object Types}

The DOT calculus proposes a new \emph{type-theoretic foundation} for Scala
and languages like it. It models
\begin{itemize}
\item \emph{path-dependent types}
\item abstract type members
\item mixture of nominal and structural typing via refinement types
\end{itemize}

It does not model
\begin{itemize}
\item inheritance and mixin composition
\item what's currently in Scala
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Path-dependent types}

\begin{description}[path-dependent type]
\item[path-dependent type] limited form of \emph{dependent type}, in which a type depends on a \emph{path}
\item[dependent type] a type which depends on a term
\item[path] a chain of immutable fields or stable values
\end{description}

\inputminted[frame=lines,fontsize=\footnotesize]{scala}{intro.scala}
\end{frame}

\begin{frame}{Selected Papers}
\begin{enumerate}
\item {\it A Type-Theoretic Approach to Higher-Order
  Modules with Sharing}\\{\footnotesize\textcolor{gray}{by Robert Harper and Mark
  Lillibridge}}\begin{itemize}
\item calculus for modules in the ML tradition
\item modules are first-class values
\end{itemize}
\item {\it Tribe: a simple virtual class calculus}\\
  {\footnotesize\textcolor{gray}{by Dave Clarke, Sophia Drossopoulou, James Noble and Tobias Wrigstad}}\begin{itemize}
\item calculus for virtual classes
\item paths are types, and types are ``generalized'' paths
\end{itemize}
\item {\it A Nominal Theory of Objects with Dependent
  Types}\\{\footnotesize\textcolor{gray}{by Martin Odersky, Vincent Cremet, Christine R{\"o}ckl and
  Matthias Zenger}}\begin{itemize}
\item calculus unifying advanced object-oriented and module systems
\item foundation for Scala
\end{itemize}
\end{enumerate}
\end{frame}

\section{Survey of Selected Papers}

\subsection{``Translucent'' ML}

\begin{frame}{SML modules}
\begin{description}[structure]
\item[structure] a module; a collection of types, values and
  (sub)structures packaged as a program unit.
\item[signature] an interface; the type of a structure; description of
  the types, values and (sub)structures of a structure given by their
  kinds, types and interfaces.
\item[functor] a function mapping structures to structures
\item[type-sharing] enables stating that types specified in separate
  modules are actually equal
\end{description}
% example?
\end{frame}

\begin{frame}[fragile]{SML modules: Example}
\inputminted[fontsize=\footnotesize]{sml}{intro.sml}
\end{frame}

\begin{frame}{Limitations of SML modules}
\begin{itemize}
\item modules are not first-class; e.g. not possible to return a
  structure from an {\tt if} expression
\item type sharing is restricted to equality between type names, not
  general type expressions; in effect, transparency / opaqueness of a
  signature cannot be fully fined-tuned % example?
\end{itemize}
\end{frame}

\begin{frame}{ML-Like: Calculus}
grounded in type theory; based on Girard's $F_\omega$, adding: % quick summary of F_\omega
\begin{itemize}
\item {\it translucent sums} to model modules
\item dependent functions to model functors
\item a notion of subtyping to model module implementation-interface matching
\end{itemize}
\end{frame}

\begin{frame}{ML-Like: Translucent Sums}
\begin{itemize}
\item translucent sums are values representing modules
\item translucent sum: sequence of bindings
\item translucent sum type: sequence of declarations
\item unlike traditional records, later fields can depend on earlier ones
\item any type can be partially or fully determined by a type expression
\item dependent typing since translucent sums are terms that may contain type components
\end{itemize}
\end{frame}

\begin{frame}[fragile]{ML-Like: Example}
\begin{minted}{sml}
structure XInt = struct
  type T = int
  val v = 3
  val f = negate
end
structure XBool = struct
  type T = bool
  val v = true
  val f = not
end
structure X =
  if flip() then XInt else XBool
signature XType = sig
  type T
  val v: T
  val f: T -> T
end
\end{minted}
\end{frame}

% Maintaing Soundness?

\begin{frame}{ML-Like: Path-Dependent Types}
\begin{itemize}
\item Scala's abstract types  $\approx$ ML's abstract types of signatures; limitations:
\begin{itemize}
\item recursive references
\item bounded quantifications
\end{itemize}
\item translucent sum can be given a more precise type by referring to the name of its type member with a path selection; essential for %example with justification for two items below?
\begin{itemize}
\item breaking the dependencies between (sub)fields
\item propagating typing information
\end{itemize}
\end{itemize}
\end{frame}

\subsection{Tribe Calculus}

\begin{frame}{Tribe Calculus: Virtual Classes}
\begin{itemize}
\item {\it families} of classes inherited together
\item classes are lexically nested inside other classes: when a class
  is inherited, its nested inner classes are inherited along with
  their methods and fields
\item two form of inheritance: subclassing and further binding
\item {\it family polymorphism}: code written for one family
  also works for extensions of that family
\item in Tribe:\begin{itemize}
\item path types can depend simultaneously on both classes and objects
\item paths can use an {\tt out} field to move from an object to the
  object which surrounds it; enables ubiquitous access to an object's
  family without the need to drag around family arguments
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Tribe: Example}
\begin{minted}{java}
class Graph {
  class Node {
    Edge connect(Node other) {
      return new Edge(this, other);
    }
  }
  class Edge {
    Node from, to;
    Edge(Node f, Node t) { from = f; to = t; }
  }
}

class ColouredGraph extends Graph { // subclassing
  class Node {                      // further binding
    Colour nodeColour;
  }
}
\end{minted}
\end{frame}

\begin{frame}[fragile]{Tribe: Example (continued)}
\begin{minted}{java}
final ColouredGraph cg1, cg2;
cg1.Node cn1, cn3;
cg2.Node cn2;
cn1.connect(cn3); // Type Correct
cn2.connect(cn3); // Type Error!!!

class Library {
  int distance(Graph.Node n1, n1.out.Node n2)  { ... }
  int distance2(Graph g, g.Node n1, g.Node n2) { ... }

  e.out.Edge copyEdge(Graph.Edge e) {
    e.out.Node from = e.from;
    e.out.Node to = e.to;
    new e.out.Edge(from, to);
  }
}
\end{minted}
\end{frame}

\begin{frame}[fragile]{Tribe Types}
\begin{itemize}
\item in Tribe, types are a form of generalized paths: a final
  variable, {\tt this} or a class name then followed by a possibly
  empty sequence of field, {\tt out} or class selections
\item {\tt kitt.Passenger.name}: the name of one of Kitt's passengers
\item {\tt kitt.driver <: Car.driver <: Car.Passenger <: Car.Traveller <:
  Vehicle.Traveller}
\item {\tt kitt.driver $\not<:$ karr.driver} and {\tt kitt.Passenger $\not<:$ karr.Passenger}
\end{itemize}
\begin{minted}[frame=lines,fontsize=\footnotesize]{java}
class Vehicle { class Traveller { ... } }
class Car extends Vehicle {
  class Passenger extends Traveller {
    class String { ... }
    final String name;
  }
  final Passenger driver;
}
final Car kitt;
final Car karr;
\end{minted}
\end{frame}

%maybe one slide on implementation?

\begin{frame}{Tribe: Discussion}
\begin{itemize}
\item no virtual classes in Scala; its virtual types can emulate some (but not all) of the benefits
\item because of {\tt out} field, Tribe has limited cross-family inheritance %example?
\item soundness? substitution lemma seems wrong when {\tt null} is
  substituted for a variable in an expression whose type contains
  that variable %details?
\item aims to have decidable type-checking, but still not proved so
\end{itemize}
\end{frame}

% Virtual Classes
% Example
% Tribe Types (generalized paths & subtyping relation)
% Follow-up
  % Ownership System?
  % Soundness?
  % Cross-Family Inheritance

\subsection{${\nu}Obj$}

\begin{frame}{${\nu}Obj$}
A calculus for classes and objects which can have types as members. It can encode:
\begin{itemize}
\item Java's inner classes
\item virtual types
\item family polymorphism
\item essential aspects of ML-like module systems, including
\begin{itemize}
\item sharing constraints
\item higher-order functors
\end{itemize}
\end{itemize}
A basis for unifying concepts  in advanced object and module systems. Connections:
\begin{itemize}
\item Object = Module
\item Object type = Signature
\item Class = Method = Functor
\end{itemize}
\end{frame}

\begin{frame}{${\nu}Obj$: Syntax}
\begin{itemize}
\item terms in ${\nu}Obj$ denote objects or classes; consist of:
\begin{description}[mixin compositions]
\item[variables] $x$
\item[selections] $t.l$
\item[object creations] \mbox{$\newin{x \larrowc t}{u}$}
\item[class templates] $\cls{x: S \sep \tup d}$
\item[mixin compositions] $t \withsub{S} u$
\end{description}
\item a value is a variable or class template
\item a path is a variable followed by a possibly empty sequence of selections
\item types in ${\nu}Obj$ consist of:
\begin{description}[mixin compositions]
\item[singleton types] $p.\type$
\item[type selections] $T\Tsel L$
\item[record types] $\obj{x \sep \tup D}$ % explain difference between record and class types?
\item[compound types] $T \with U$
\item[class types] $\cls{x: S \sep \tup D}$
\end{description}
\end{itemize}
\end{frame}

\begin{frame}{${\nu}Obj$: Details}
\begin{itemize}
\item type bindings
\begin{description}[abstract types] %examples?
\item[type aliases] $=$
\item[new types] $\expand$
\item[abstract types] $<:$
\end{description}
\item class template $\cls{x: S \sep \tup d}$ related to translucent sum; some differences:
\begin{itemize}
\item needs to be instantiated
\item ``contractive'' restriction
\end{itemize}
\item class type $\cls{x: S \sep \tup D}$
\begin{itemize}
\item contains as values classes that instantiate to objects of (sub)type $\obj{x \sep \tup D}$
\item explicit self type $S$ may be different from $\obj{x \sep \tup D}$
\item declarations in $S$ which are not in $\tup D$ play the role of abstract members, defined by mixin composition during instantiation
\end{itemize}
\end{itemize}
\end{frame}

% can you make this slide less cluttered?
\begin{frame}[fragile]{${\nu}Obj$: Example (encoding of monomorphic functions)}
A $\lambda$-abstraction $\lambda ( x : T )\; t$ is represented as a
class with an abstract member \code!arg! for the function argument:
\begin{lstlisting}
[x: {arg: T}| fun = [res = $t'$]]
\end{lstlisting}
$t'$ corresponds to term $t$ in which all occurrences of $x$ are
replaced by \code!$x$.arg!. We cannot directly access \code!arg! on
the right-hand side of \code!fun!: this wouldn't be ``contractive'',
because \code!arg! might not be initialized before \code!fun!. Hence,
we pack $t'$ in another class to ensure contractiveness. Now, an
application $g(e)$ gets decomposed into three subsequent steps:
\begin{lstlisting}
$\nu\,$g$_{app}$  <- g & [arg = e];
$\nu\,$g$_{eval}$ <- g$_{app}$.fun;
g$_{eval}$.res
\end{lstlisting}
First we instantiate function \code!g! with a concrete argument
yielding a thunk \code!g$_{app}$!. Then we evaluate this thunk by
creating an instance \code!g$_{eval}$! of it. Finally we extract the
result by querying field \code!res! of \code!g$_{eval}$!.
\end{frame}

\begin{frame}[fragile]{${\nu}Obj$: Discussion}
\begin{itemize}
\item conflate the concepts of compound types (which inherit the
  members of several parent types) and mixin composition (which build
  classes from other classes and traits)
\item mixin composition is not commutative, unlike classical
  intersection types
\item in Scala, least upper bounds and greatest lower bounds do not always exist, e.g: %can you translate this to nuObj?
\end{itemize}
\begin{minted}{scala}
  trait A { type T <: A }
  trait B { type T <: B }
  // glb is approximated by an infinite sequence
  A with B { type T <: A with B { type T <: A with B {
    type T <: ...
  }}}
\end{minted}
\end{frame}

\section{Proposal}
\begin{frame}{DOT: Dependent Object Types}
\begin{itemize}
\item core calculus for modeling {\it path-dependent types}
\item we've seen path-dependent types arise in three settings:
\begin{itemize}
\item ML-like module systems
\item virtual classes
\item ${\nu}Obj$ / Scala
\end{itemize}
\item DOT aims to bring more uniformity and simplicity to Scala
\begin{itemize}
\item replace Scala's compound types with classical intersection types
\item complement calculus with classical union types
\item intersections and unions form a lattice wrt subtyping
\end{itemize}
\end{itemize}
\end{frame}

\section{Backup Slides}

% System F omega
% System F sub
\end{document}
