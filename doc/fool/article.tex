\documentclass[9pt]{sigplanconf}
\input{dot_macros}
\begin{document}

\conferenceinfo{FOOL '12}{October 22, 2012, Tucson, AZ, USA.} 
\copyrightyear{2012} 
\copyrightdata{[to be supplied]} 

\title{Dependent Object Types}
\subtitle{Towards a foundation for Scala's type system}

\authorinfo{Nada Amin \and Adriaan Moors \and Martin Odersky}
           {EPFL}
           {first.last@epfl.ch}

\maketitle

\begin{abstract}
We propose a new type-theoretic foundation of Scala and languages like
it: the Dependent Object Types (DOT) calculus. DOT models Scala's
path-dependent types, abstract type members and its mixture of nominal
and structural typing through the use of refinement types. The core
formalism makes no attempt to model inheritance and mixin
composition. DOT normalizes Scala's type system by unifying the
constructs for type members and by providing classical intersection
and union types which simplify glb/lub computations.

In this paper, we present the DOT calculus, both formally and
informally. We also discuss our work-in-progress to prove type-safety
of the calculus.
\end{abstract}

\category{D.3.3}{Language Constructs and Features}{Abstract data types, Classes and objects, polymorphism}
\category{D.3.1}{Formal Definitions and Theory}{Syntax, Semantics}
\category{F.3.1}{Specifying and Verifying and Reasoning about Programs}{}
\category{F.3.3}{Studies of Program Constructs}{Object-oriented constructs, type structure}
\category{F.3.2}{Semantics or Programming Languages}{Operational semantics}

\terms
Languages, Theory, Verification

\keywords
calculus, objects, dependent types%, step-indexed logical relations

\section{Introduction}
A scalable programming language is one in which the same concepts can
describe small as well as large parts. Towards this goal, Scala
unifies concepts from object and module systems. An essential
ingredient of this unification is objects with type members. Given a
stable path to an object, its type members can be accessed as types,
called path-dependent types.

This paper presents Dependent Object Types (DOT), a small object
calculus with path-dependent types. In addition to path-dependent
types, types in DOT are built from refinements, intersections and
unions. A refinement extends a type by (re-)declaring members, which
can be types, values or methods.

We propose DOT as a new type-theoretic foundation of Scala and
languages like it. The properties we are interested in modeling are
Scala's path-dependent types and abstract type members, as well as its
mixture of nominal and structural typing through the use of refinement
types. Compared to previous approaches~\cite{nuObj,FS}, we make no
attempt to model inheritance or mixin composition. Indeed we will
argue that such concepts are better modeled in a different setting.

The DOT calculus does not precisely describe what's currently in Scala. It
is more normative than descriptive. The main point of deviation
concerns the difference between Scala's compound type formation using
{\bf with} and classical type intersection, as it is modeled in the
calculus. Scala, and the previous calculi attempting to model it,
conflates the concepts of compound types (which inherit the members of
several parent types) and mixin composition (which build classes from
other classes and traits). At first glance, this offers an economy of
concepts. However, it is problematic because mixin composition and
intersection types have quite different properties. In the case of
several inherited members with the same name, mixin composition has to
pick one which overrides the others. It uses for that the concept of
linearization of a trait hierarchy. Typically, given two independent
traits $T_1$ and $T_2$ with a common method $m$, the mixin composition
\code@$T_1$ with $T_2$@ would pick the $m$ in $T_2$, whereas the member in
$T_1$ would be available via a super-call. All this makes sense from
an implementation standpoint. From a typing standpoint it is more
awkward, because it breaks commutativity and with it several
monotonicity properties.

In the present calculus, we replace Scala's compound types by
classical intersection types, which are commutative. We also
complement this by classical union types. Intersections and unions
form a lattice wrt subtyping. This addresses another problematic
feature of Scala: In Scala's current type system, least upper bounds
and greatest lower bounds do not always exist. Here is an example:
given two traits \code{A} and \code{B}, where each declares an
abstract upper-bounded type member \code{T},
\begin{lstlisting}
  trait A { type T <: A }
  trait B { type T <: B }
\end{lstlisting}
the greatest lower bound of \code{A} and \code{B} is approximated by the
infinite sequence
\begin{lstlisting}
  A with B { type T <: A with B { type T <: A with B {
    type T < ...
  }}}
\end{lstlisting}
The limit of this sequence does not exist as a type in Scala.

This is problematic because glbs and lubs play a central role in
Scala's type inference. For example, in order to infer the type of an
\code{if} expression such as
\begin{lstlisting}
  if (cond) ((a: A) => c: C) else ((b: B) => d: D)
\end{lstlisting}
type inference tries to compute the glb of \code{A} and \code{B} and
the lub of \code{C} and \code{D}. The absence of universal glbs and
lubs makes type inference more brittle and more unpredictable.

Compared to Scala, DOT also simplifies type members. In DOT, a type
member is declared by its lower and upper bounds. Here is an example
inspired by~\cite{vt}:
\begin{lstlisting}
trait Food
trait Animal {
  type Meal <: Food
  def eat(meal: Meal) {}
}
\end{lstlisting}
\code{Meal} is a type member with a lower bound of $\Bot$ and an upper
bound of \code{Food}. It is possible to instantiate an \code{Animal}
without further specifying \code{Meal}, though it would not be
possible to feed it. Now, we define \code{Cow} by refining
\code{Animal}.
\begin{lstlisting}
trait Grass extends Food
trait Cow extends Animal {
  type Meal = Grass
}
\end{lstlisting}
In Scala, the type alias \code{type Meal = Grass} defines a concrete
binding for \code{Meal}. In DOT, such a type alias is declared by
giving it identical lower and upper bounds. Now, we can instantiate
\code{Cow}s and feed them \code{Grass}.

DOT has a notion of concrete vs abstract type members, which is used
to distinguish which types members are instantiable. In the example
above, all types introduced by \code{trait} would be concrete type
members in DOT with lower bounds of $\Bot$ and upper bounds describing
the \code{extends} clause: $\Top$ for \code{Food}, a refinement of
$\Top$ with type member \code{Meal} and method member \code{eat} for
\code{Animal}, \code{Food} for \code{Grass} and a refinement of
\code{Animal} with type member \code{Meal} for \code{Cow}. Concrete
type members typically have a lower bound of $\Bot$ so that they are
purely nominal: e.g. one needs to directly or indirectly instantiate a
\code{Cow} to have an object of type \code{Cow}.

We propose DOT as a core calculus for path-dependent types. We present
the calculus formally in section \ref{dot-calculus} and through
examples in section~\ref{dot-examples}. Though we show that the
calculus does not satisfy the standard theorem of preservation in
section~\ref{dot-preservation}, we contribute a proof sketch of type
safety using logical relations in section~\ref{dot-type-safety}. In
section~\ref{discussion}, we discuss choices and variants of the
calculus, as well as related work, and conclude in
section~\ref{conclusion}.

\section{The DOT Calculus}\label{dot-calculus}

\boxfig{dot-one}{The DOT Calculus : Syntax, Reduction, Type / Declaration Assignment}{
{\bf Syntax}\medskip
\begin{center}    
$\ba{l@{\hspace{0.2mm}}|@{\hspace{0.2mm}}l}
\ba[t]{l@{\hspace{10mm}}l}
x, y, z    & \lindent{\mbox{Variable}} \\
l          & \lindent{\mbox{Value label}}\\
m          & \lindent{\mbox{Method label}}\\[0.2em]
v ::=      & \lindent{\mbox{Value}} \\
\gap x     & \mbox{variable} \\[0.2em]
t ::=      & \lindent{\mbox{Term}} \\
\gap v     & \mbox{value} \\
\gap \new x c t & \mbox{new instance} \\
\gap t.l  & \mbox{field selection} \\
\gap \mapp t m t  & \mbox{method invocation} \\[0.2em]
p ::= & \lindent \mbox{Path} \\
\gap x & \mbox{variable} \\
\gap p.l & \mbox{selection} \\
c ::= T_c \ldefs{\seq{d}} & \lindent{\mbox{Constructor}} \\[0.2em]
d ::= & \lindent{\mbox{Initialization}}\\
\gap l = v & \mbox{field initialization}\\
\gap m(x) = t & \mbox{method initialization}\\
s      ::= \seq{x \mapsto c} & \lindent\mbox{Store}
\ea
&
\ba[t]{l@{\hspace{10mm}}l}
L ::=      & \lindent{\mbox{Type label}} \\
\gap L_c   & \mbox{class label} \\
\gap L_a   & \mbox{abstract type label} \\[0.2em]
S,T,U,V,W ::= & \lindent\mbox{Type}\\
\gap p.L & \mbox{type selection} \\
\gap T \refine z {\seq D} & \mbox{refinement} \\
\gap T \tand T & \mbox{intersection type} \\
\gap T \tor T & \mbox{union type} \\
\gap \Top  & \mbox{top type} \\
\gap \Bot  & \mbox{bottom type} \\[0.2em]
S_c, T_c ::= & \lindent \mbox{Concrete type} \\
\multicolumn{2}{l}{\gap p.L_c ~|~ T_c \refine z {\seq D} ~|~ T_c \wedge T_c  ~|~ \Top} \\[0.2em]
D ::= & \lindent\mbox{Declaration} \\
\gap \Ldecl L S U & \mbox{type declaration} \\
\gap \ldecl l T   & \mbox{value declaration} \\
\gap \mdecl m S U & \mbox{method declaration}\\
\ \\
\Gamma ::= \seq{x \typ T} & \lindent\mbox{Environment}
\ea
\ea$
\end{center}
\medskip

\linesep

\begin{multicols}{2}[\judgement{Reduction}{\fbox{$\reduction t s {t'} {s'}$}}]

\infrule[\textsc{msel}]
{y \mapsto T_c \ldefs{\seq{l = v'}\;\seq{m(x)=t}} \in s}
{\reduction {\mapp y {m_i} v} s {\subst v {x_i} {t_i}} s}

\infrule[\textsc{sel}]
{y \mapsto T_c \ldefs{\seq{l = v}\;\seq{m(x)=t}} \in s}
{\reduction {y.l_i} s {v_i} s}

\infax[\textsc{new}]
{\reduction {\new x c t} s t {s \envplus{x \mapsto c}}}

\infrule[\textsc{context}]
{\reduction t s {t'} {s'}}
{\reduction {e[t]} s {e[t']} s'}
\end{multicols}

\hfill {\bf where} evaluation context $\gap e ::= [\,] ~|~ \mapp e m t ~|~ \mapp v m e ~|~ e.l\hspace{2cm}$

\linesep

\begin{multicols}{2}[\judgement{Type Assignment}{\fbox{$\Gamma \ts t \typ T$}}]

\infrule[\textsc{var}]
{x \typ T \in \Gamma}
{\Gamma \ts x \typ T}

\infrule[\textsc{msel}]
{\Gamma \ts t \ni m \typ {S \tfun T} \\
 \Gamma \ts t' \typ T' \spcomma T' \sub S}
{\Gamma \ts \mapp t m {t'} \typ T}

\infrule[\textsc{sel}]
{\Gamma \ts t \ni l \typ T'}
{\Gamma \ts t.l \typ T'}

\infrule[\textsc{new}]
{
y \notin \fn(T') \\
\Gamma \ts T_c \wfe \spcomma T_c \expand_y \seq{\Ldecl L S U}, \seq{D} \\
\Gamma \envplus{y: T_c} \ts \seq{S <: U} \spcomma \seq{d} \typ \seq{D} \spcomma {t'} \typ {T'}}
{\Gamma \ts \new y {T_c \ldefs{\seq{d}}} {t'} \typ T'}

\end{multicols}

\linesep

\begin{multicols}{2}[\judgement{Declaration Assignment}{\fbox{$\Gamma \ts d \typ D$}}]

\infrule[\textsc{vdecl}]
{\Gamma \ts v \typ {V'} \spcomma {V'} \sub V}
{\Gamma \ts (l = v) \typ (\ldecl l V)}

\infrule[\textsc{mdecl}]
{\Gamma \ts S \wfe\\
 \Gamma \envplus{x : S} \ts t \typ {T'} \spcomma {T'} \sub T}
{\Gamma \ts (m(x) = t) \typ (\mdecl m S T) }

\end{multicols}

} % END dot-one

The DOT calculus is a small system of dependent
object-types. \figref{dot-one} gives its syntax, reduction rules,
and type assignment rules.

\subsection{Notation} We use standard notational conventions for
sets. The notation $\seq{X}$ denotes a set of elements $X$. Given
such a set $\seq X$ in a typing rule, $X_i$ denotes an arbitrary
element of $X$. 
%The $\uplus$ operator extends a set of bindings. It is required that the added binding does not
%introduce a variable which is already bound in the base-set.
We use an
abbreviation for preconditions in typing judgements. Given an
environment $\Gamma$ and some predicates $P$ and $Q$, the condition $\Gamma \ts P \spcomma Q$
is a shorthand for the two conditions $\Gamma \ts P$ and $\Gamma \ts Q$.

\subsection{Syntax}

There are four alphabets: Variable names $x$, $y$, $z$ are freely
alpha-renamable. They occur as parameters of methods, as
binders for objects created by \verb@new@-expressions, and as self
references in refinements. Value labels $l$ denote fields in objects,
which are bound to values at run-time. Similarly, method labels $m$
denote methods in objects. Type labels $L$ denote type members of
objects. Type labels are further separated into labels for abstract
types $L_a$ and labels for classes $L_c$. It is assumed that in each
program every class label $L_c$ is declared at most once.

We assume that the label alphabets $l$, $m$ and $L$ are finite. This is
not a restriction in practice, because one can include in these 
alphabets every label occurring in a given program.

The terms $t$ in DOT consist of variables $x$, $y$, $z$, field
selections $t.l$, method invocations $t.m(t)$ and object creation
expressions $\new y c {t'}$ where $c$ is a constructor $T_c \ldefs{\seq{l
    = v}\;\seq{m(x) = t}}$. The latter binds a variable $y$ to a new
instance of type $T_c$ with fields $\seq l$ initialized to values
$\seq v$ and methods $\seq m$ initialized to methods of one parameter
$\seq{x}$ and body $\seq{t}$.  The scope of $y$ extends through the term
${t'}$.

Two sub-sorts of terms are values and paths. Values $v$ consist of
just variables. Paths $p$ consist of just variables and field
selections.

The types in DOT are denoted by letters $S$, $T$, $U$, $V$, or $W$. They consist of the following:
\begin{itemize}
\item[-] Type selections $p.L$, which denote the type member $L$ of path $p$.
\item[-] Refinement types $T \refine z {\seq D}$, which refine a type $T$ by a set of declarations $D$.
         The variable $z$ refers to the ``self''-reference of the type. Declarations can refer to
         other declarations in the same type by selecting from $z$.
\item[-] Type intersections $T \tand T'$, which carry the declarations of members present in either $T$ or $T'$.
\item[-] Type unions $T \tor T'$, which carry only the declarations of members present in both $T$ and $T'$.
\item[-] A top type $\Top$, which corresponds to an empty object.
\item[-] A bottom type $\Bot$, which represents a non-terminating computation.
\end{itemize}
A subset of types $T_c$ are called {\em concrete types}. These are type selections
$p.L_c$ of class labels,
the top type $\Top$, intersections of concrete types, and refinements $T_c \refine z {\seq D}$ of concrete types. Only concrete types are allowed in constructors $c$.

There are only three forms of declarations in DOT, which are all part
of refinement types.  A value declaration $\ldecl l T$ introduces a
field with type $T$.  A method declaration $\mdecl m S U$ introduces a
method with parameter of type $S$ and result of type $U$. A type
declaration $\Ldecl L S U$ introduces a type member $L$ with a lower
bound type $S$ and an upper bound type $U$. There are no type aliases,
but a type alias can be simulated by a type declaration $\Ldecl L T T$
where the lower bound and the upper bound are the same type $T$.

\boxfig{dot-decls}{The DOT Calculus : Declaration Lattice}{

\bda{lcl@{\gap}l}
    
      \dom(\seq D \tand \seq {D'}) &~=~& \dom(\seq{D}) \cup \dom(\seq{D'}) \\
      \dom(\seq D \tor \seq {D'}) &=& \dom(\seq{D}) \cap \dom(\seq{D'}) \\[0.5em]
      (D \tand D')(L) &=&
        \Ldecl L {(S \tor S')} {(U \tand U')} & \mbox{if~} (\Ldecl L S U) \in \seq{D} \;\mbox{and}\; (\Ldecl L {S'} {U'}) \in \seq{D'} \\
        &=& D(L) & \mbox{if~} L \notin \dom(\seq{D'}) \\
        &=& D'(L) & \mbox{if~} L \notin \dom(\seq{D}) \\
      (D \tand D')(m) &=&
        \mdecl m {(S \tor S')} {(U \tand U')} & \mbox{if~} (\mdecl m S U) \in \seq{D} \;\mbox{and}\; (\mdecl m {S'} {U'}) \in \seq{D'} \\
        &=& D(m) & \mbox{if~} m \notin \dom(\seq{D'}) \\
        &=& D'(m) & \mbox{if~} m \notin \dom(\seq{D}) \\
      (D \tand D')(l) &=&
        \ldecl l {T \tand T'} & \mbox{if~} (\ldecl l T) \in \seq{D} \;\mbox{and}\; (\ldecl l {T'}) \in \seq{D'} \\
        &=& D(l) & \mbox{if~} l \notin \dom(\seq{D'}) \\
        &=& D'(l) & \mbox{if~} l \notin \dom(\seq{D}) \\[0.5em]
      (D \tor D')(L) &=&
        \Ldecl L {(S \tand S')} {(U \tor U')} & \mbox{if~} (\Ldecl L S U) \in \seq{D} \;\mbox{and}\; (\Ldecl L {S'} {U'}) \in \seq{D'} \\
      (D \tor D')(m) &=&
        \mdecl m {(S \tand S')} {(U \tor U')} & \mbox{if~} (\mdecl m S U) \in \seq{D} \;\mbox{and}\; (\mdecl m {S'} {U'}) \in \seq{D'} \\
      (D \tor D')(l) &=&
        \ldecl l {T \tor T'} & \mbox{if~} (\ldecl l T) \in \seq{D} \;\mbox{and}\; (\ldecl l {T'}) \in \seq{D'} 
    \eda

Sets of declarations form a lattice with the given meet $\wedge$ and
join $\vee$, the empty set of declarations as the top element, and the
bottom element $\seq{D_\Bot}$, Here $\seq{D_\Bot}$ is the set of
declarations that contains for every term label $l$ the declaration
$\ldecl l \Bot$, for every type label $L$ the declaration $\Ldecl L
\Top \Bot$ and for every method label $m$ the declaration $\mdecl m
\Top \Bot$.
}

Every value, method or type label can be declared only once in a set of
declarations $\seq D$. A set of declarations can hence be seen as a map from
labels to their declarations.  Meets $\wedge$ and joins $\vee$ on sets of
declarations are defined in ~\figref{dot-decls}.

\subsection{Reduction rules}

Reduction rules $\reduction t s {t'} {s'}$ in DOT rewrite pairs of
terms $t$ and stores $s$, where stores map variables to constructors.
There are three main reduction rules: Rule (\textsc{msel}) rewrites a
method invocation $\mapp y {m_i} v$ by retrieving the corresponding method
definition from the store, and performing a substitution of the
argument for the parameter in the body. Rule (\textsc{sel}) rewrites a
field selection $x.l$ by retrieving the corresponding value from the
store. Rule (\textsc{new}) rewrites an object creation $\new x c t$ by
placing the binding of variable $x$ to constructor $c$ in the store
and continuing with term $t$.  These reduction rules can be applied
anywhere in a term where the hole $[\,]$ of an evaluation context $e$
can be situated.

\subsection{Type assignment rules}

The last part of \figref{dot-one} presents rules for type
assignment.  

Rules (\textsc{sel}) and (\textsc{msel}) type field selections and
method invocations by means of an auxiliary membership relation $\ni$,
which determines whether a given term contains a given declaration as
one of its members. The membership relation is defined in
\figref{dot-two} and is further explained in section~\ref{mem}.

The last rule, (\textsc{new}), assigns types to object creation
expressions. It is the most complex of DOT's typing rules.  To
type-check an object creation $\new y {T_c \ldefs {\seq{l =
      v}\;\seq{m(x) = t}}} t'$, one verifies first that the type $T_c$
is well-formed (see \figref{dot-wf} for a definition of
well-formedness).  One then determines the set of all declarations
that this type carries, using the expansion relation $\expand$ defined
in \figref{dot-two}.  Every type declaration $\Ldecl L S U$ in
this set must be realizable, i.e.\ its lower bound $S$ must be a
subtype of its upper bound $U$.  Every field declaration $\ldecl l V$
in this set must have a corresponding initializing value of $v$ of
type $V$.  These checks are made in an environment which is extended
by the binding $y: T_c$. In particular this allows field values that
recurse on ``self'' by referring to the bound variable $x$. Similarly,
every method declaration $\mdecl m T W$ must have a corresponding
initializing method definition $m(x) = t$. The parameter type $T$ must
be $\nswfe$ (well-formed and expanding; see \figref{dot-wf}), and
the body $t$ must type check to $W$ in an environment extended by the
bindings $y : T_c$ and $x : T$.

Instead of adding a separate subsumption rule, subtyping is expressed
by preconditions in rules (\textsc{msel}) and (\textsc{new}).

\boxfig{dot-two}{The DOT Calculus : Membership and Expansion}{
    \begin{multicols}{2}[\judgement{Membership}{\fbox{$\Gamma \ts t \ni D$}}]

      \infrule[\textsc{path-$\ni$}]
      {\Gamma \ts p \typ T \spcomma T \expand_z \seq D}
      {\Gamma \ts p \ni \subst p z {D_i}}

      \infrule[\textsc{term-$\ni$}]
      {z \not\in \fn(D_i) \andalso \Gamma \ts t \typ T \spcomma T \expand_z \seq D}
      {\Gamma \ts t \ni D_i}
   \end{multicols}

   \linesep

    \begin{multicols}{2}[\judgement{Expansion}{\fbox{$\Gamma \ts T \expand_z \seq D$}}]  

      \infrule[\textsc{rfn-$\expand$}]
      {\Gamma \ts T \expand_z {\seq {D'}}}
      {\Gamma \ts T \refine z {\seq D} \expand_z \seq {D'} \tand \seq D}

      \infrule[\textsc{$\tand$-$\expand$}]
      {\Gamma \ts T_1 \expand_z {\seq D_1} \spcomma T_2 \expand_z {\seq D_2}}
      {\Gamma \ts T_1 \tand T_2 \expand_z {\seq D_1 \tand \seq D_2}}

      \infax[\textsc{$\Top$-$\expand$}]
      {\Gamma \ts \Top \expand_z \{\}}

      \infrule[\textsc{tsel-$\expand$}]
      {\Gamma \ts p \ni \Ldecl L S U \spcomma U \expand_z \seq D}
      {\Gamma \ts p.L \expand_z \seq D}

      \infrule[\textsc{$\tor$-$\expand$}]
      {\Gamma \ts T_1 \expand_z {\seq D_1} \spcomma T_2 \expand_z {\seq D_2}}
      {\Gamma \ts T_1 \tor T_2 \expand_z {\seq D_1 \tor \seq D_2}}

      \infax[\textsc{$\Bot$-$\expand$}]
      {\Gamma \ts \Bot \expand_z \seq{D_\Bot}}
    \end{multicols}

} % END dot-two

\subsection{Membership}\label{mem}

\figref{dot-two} presents typing rules for membership and expansion.
The membership judgement $\Gamma \ts t \ni D$ states that in
environment $\Gamma$ a term $t$ has a declaration $D$ as a member. The
membership rules rely on expansion. There are two rules, one for paths
(\textsc{path-$\ni$}) and one for general terms
(\textsc{term-$\ni$}). For general terms, the ``self''-reference of
the type must not occur in the resulting declaration $D$, since, to
guarantee syntactic validity, we can only substitute a path for the
``self''-reference.

\subsection{Expansion}

The expansion judgement $\Gamma \ts T \expand_z {\seq {D}}$
``flattens'' all the declarations of a type: it relates a type $T$ to
a set of declarations that describe the type structurally. Expansion
is precise and unique, though it doesn't always exist. See
section~\ref{ex-exp} for examples.
      
The expansion relation $\expand$ is needed to typecheck the complete
set of declarations carried by a concrete type that is used in a
\textbf{new}-expression. Expansion is also used by the membership
rules and in subtyping refinements on the right (see
\figref{dot-sub}).

Rule (\textsc{rfn-$\expand$}) states that a refinement type $T
\expand_z {\seq D}$ expands to the conjunction of the expansion $\seq {D'}$
of $T$ and the newly added declarations $\seq D$. Rule
(\textsc{tsel-$\expand$}) states that a type selection $p.L$ carries
the same declarations as the upper bound $U$ of $L$ in $T$.  Rules
($\tand$-$\expand$) and ($\tor$-$\expand$) states that expansion
distributes through meets and joins.  Rule (\textsc{$\top$-$\expand$})
states that the top type $\top$ expands to the empty set. Rule
(\textsc{$\bot$-$\expand$}) states that the bottom type $\bot$ expands
to the bottom element $\seq{D_\Bot}$ of the lattice of sets of
declarations (recall \figref{dot-decls}).

\boxfig{dot-sub}{The DOT Calculus : Subtyping and Declaration Subsumption}{

    \begin{multicols}{2}[\judgement{Subtyping}{\fbox{$\Gamma \ts S \sub T$}}]

%      \infrule[\textsc{trans}]
%      {\Gamma \ts S \sub T \spcomma T \sub U}
%      {\Gamma \ts S \sub U}

      \infrule[\textsc{refl}]
      {\Gamma \ts T \wfe}
      {\Gamma \ts T \sub T}

      \infrule[\textsc{$\sub$-rfn}]
      {\Gamma \ts {T \refine z {\seq D}} \wfe
       \spcomma S \sub T \spcomma S \expand_z \seq{D'} \\
       \Gamma \envplus{z: S} \ts \seq{D' \sub D}}
      {\Gamma \ts S \sub T \refine z {\seq D}}

      \infrule[\textsc{$\sub$-tsel}]
      {\Gamma \ts p \ni \Ldecl L S U \spcomma S \sub U \spcomma S' \sub S }
      {\Gamma \ts S' \sub p.L}

      \infrule[\textsc{$\sub$-$\tand$}]
      {\Gamma \ts T \sub T_1 \spcomma T \sub T_2}
      {\Gamma \ts T \sub T_1 \tand T_2}

      \infrule[\textsc{$\sub$-$\tor_1$}]
      {\Gamma \ts T_2 \wfe \spcomma T \sub T_1}
      {\Gamma \ts T \sub T_1 \tor T_2}

      \infrule[\textsc{$\sub$-$\tor_2$}]
      {\Gamma \ts T_1 \wfe \spcomma T \sub T_2}
      {\Gamma \ts T \sub T_1 \tor T_2}
      
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      \infrule[\textsc{$\sub$-$\Top$}]
      {\Gamma \ts T \wfe}
      {\Gamma \ts T \sub \Top}

      \infrule[\textsc{$\Bot$-$\sub$}]
      {\Gamma \ts T \wfe}
      {\Gamma \ts \Bot \sub T}

      \infrule[\textsc{rfn-$\sub$}]
      {\Gamma \ts {T \refine z {\seq D}} \wfe
       \spcomma T \sub T'}
      {\Gamma \ts T \refine z {\seq D} \sub T'}

      \infrule[\textsc{tsel-$\sub$}]
      {\Gamma \ts p \ni \Ldecl L S U \spcomma S \sub U \spcomma U \sub U'}
      {\Gamma \ts p.L \sub U'}

      \infrule[\textsc{$\tor$-$\sub$}]
      {\Gamma \ts T_1 \sub T \spcomma T_2 \sub T}
      {\Gamma \ts T_1 \tor T_2 \sub T}

      \infrule[\textsc{$\tand_1$-$\sub$}]
      {\Gamma \ts T_2 \wfe \spcomma T_1 \sub T}
      {\Gamma \ts T_1 \tand T_2 \sub T}

      \infrule[\textsc{$\tand_2$-$\sub$}]
      {\Gamma \ts T_1 \wfe \spcomma T_2 \sub T}
      {\Gamma \ts T_1 \tand T_2 \sub T}

      \end{multicols}

    \linesep

    \begin{multicols}{2}[\judgement{Declaration subsumption}{\fbox{$\Gamma \ts D \sub D'$}}]

    \infrule[\textsc{tdecl-$\sub$}]
            {\Gamma \ts S' \sub S \spcomma T \sub T'}
            {\Gamma \ts (\Ldecl L S T) \sub (\Ldecl L {S'} {T'})}

    \infrule[\textsc{vdecl-$\sub$}]
            {\Gamma \ts T \sub T'}
            {\Gamma \ts (\ldecl l T) \sub (\ldecl l {T'})}

    \infrule[\textsc{mdecl-$\sub$}]
            {\Gamma \ts S' \sub S \spcomma T \sub T'}
            {\Gamma \ts (\mdecl m S T) \sub (\mdecl m {S'} {T'})}

    \end{multicols}
} % END dot-sub

\subsection{Subtyping}

\figref{dot-sub} defines the subtyping judgement $\Gamma \ts S
\sub T$ which states that in environment $\Gamma$ type $S$ is a
subtype of type $T$. Subtyping is regular wrt $\nswfe$: if
type $S$ is a subtype of type $T$, then $S$ and $T$ are well-formed
and expanding. Though this regularity limits our calculus to
$\nswfe$-types, this limitation allows us to show that subtyping is
transitive, as discussed in section~\ref{dot-variants-why-wfe}.

\subsection{Declaration Subsumption}

The declaration subsumption judgement $\Gamma \ts D \sub D'$ in
\figref{dot-sub} states that in environment $\Gamma$ the declaration
$D$ subsumes the declaration $D'$. There are three rules, one for each
kind (type, value, method) of declarations.  Rule
(\textsc{tdecl-$\sub$}) states that a type declaration $\Ldecl L S U$
subsumes another type declaration $\Ldecl L {S'} {U'}$ if $S'$ is a
subtype of $S$ and $U$ is a subtype of $U'$. In other words, the set
of types between $S$ and $U$ is contained in the set of types between
$S'$ and $U'$.  Rule (\textsc{vdecl-$\sub$}) states that a value
declaration $\ldecl l T$ subsumes another value declaration $\ldecl l
T'$ if $T$ is a subtype of $T'$. Rule (\textsc{mdecl-$\sub$}) is
similar to (\textsc{tdecl-$\sub$}), as the parameter type varies
contravariantly and the return type covariantly.

Declaration subsumption is extended to a binary relation between
sequences of declarations: $\seq{D} <: \seq{D'}$ iff $\forall D'_i,
\exists D_j. {D_j \sub D'_i}$.

\boxfig{dot-wf}{The DOT Calculus : Well-Formedness}{

       \begin{multicols}{2}[\judgement{Well-formed types}{\fbox{$\Gamma \ts T \wf$}}]

      \infrule[\textsc{rfn-wf}]
      {\Gamma \ts T \wf \\ 
       \Gamma \envplus {z: T \refine z {\seq D}} \ts \seq {D \wf}}
      {\Gamma \ts T \refine z {\seq D} \wf}

      \infrule[\textsc{tsel-wf$_1$}]
      {\Gamma \ts p \ni \Ldecl L S U \spcomma S \wf \spcomma U \wf}
      {\Gamma \ts p.L \wf}

      \infrule[\textsc{$\tand$-wf}]
      {\Gamma \ts T \wf \spcomma T' \wf}
      {\Gamma \ts T \tand T' \wf}

      %%%%%%%%%%%%%%%%%%%%%%%%%%%

      \infax[\textsc{$\Top$-wf}]
      {\Gamma \ts \Top \wf}

      \infax[\textsc{$\Bot$-wf}]
      {\Gamma \ts \Bot \wf}

      \infrule[\textsc{tsel-wf$_2$}]
      {\Gamma \ts p \ni \Ldecl L \Bot U}
      {\Gamma \ts p.L \wf}

      \infrule[\textsc{$\tor$-wf}]
      {\Gamma \ts T \wf \spcomma T' \wf}
      {\Gamma \ts T \tor T' \wf}

    \end{multicols}

    \linesep

    \begin{multicols}{2}[\judgement{Well-formed declarations}{\fbox{$\Gamma \ts D \wf$}}]
      \infrule[\textsc{tdecl-wf}]
      {\Gamma \ts S \wf \spcomma U \wf}
      {\Gamma \ts \Ldecl L S U \wf}

      \infrule[\textsc{vdecl-wf}]
      {\Gamma \ts T \wf}
      {\Gamma \ts \ldecl l T \wf}

      \infrule[\textsc{mdecl-wf}]
      {\Gamma \ts S \wf \spcomma U \wf}
      {\Gamma \ts \mdecl m S U \wf}

    \end{multicols}

    \linesep

    \begin{multicols}{2}[\judgement{Well-formed and expanding types}{\fbox{$\Gamma \ts T \wfe$}}]
      \infrule[\textsc{wfe}]
      {\Gamma \ts T \wf \spcomma T \expand_z \seq{D}}
      {\Gamma \ts T \wfe}
    \end{multicols}
} % END dot-wf

\subsection{Well-formedness}

The well-formedness judgement $\Gamma \ts T \wf$ in \figref{dot-wf}
states that in environment $\Gamma$ the type $T$ is
well-formed.

A refinement type $T \refine z {\seq D}$ is
well-formed if the parent type $T$ is well-formed and every
declaration in $\seq D$ is well-formed in an environment augmented by
the binding of the self-reference $z$ to the refinement type itself
(\textsc{rfn-wf}).

A type selection $p.L$ is well-formed if $L$ is a member of $p$, and
the lower bound of $L$ is also well-formed (\textsc{tsel-wf$_1$} and
\textsc{tsel-wf$_2$}). The latter condition has the effect that the
lower bound of a type $p.L$ may not refer directly or indirectly to a
type containing $p.L$ itself --- if it would, the well-formedness
judgement of $p.L$ would not have a finite proof. No such restriction
exists for the upper bound of $L$ if the lower bound is $\bot$
(\textsc{tsel-wf$_2$}). The upper bound may in fact refer back to the
type. Hence, recursive class types and F-bounded abstract types are
both expressible.

The other forms of types in DOT are all well-formed if their
constituent types are well-formed.

Well-formedness extends straightforwardly to declarations with the
judgement $\Gamma \ts D \wf$. All declarations are well-formed if
their constituent types are well-formed.

\section{Examples}\label{dot-examples}

\subsection{Glbs and Lubs}

In DOT, the glb of two types is their intersection and their lub,
their union. Recall the introductory example which was problematic in
Scala:
\begin{lstlisting}
  trait A { type T <: A }
  trait B { type T <: B }
\end{lstlisting}

We represent it as follows in DOT, wrapping the types in a namespace $p$:
\begin{align*}
\mlnew p {&\Top \mlrefine p {\\
&\ \Ldecl {A_c} \Bot {\Top \refine z {\Ldecl T \Bot {p.A_c}}}\\
&\ \Ldecl {B_c} \Bot {\Top \refine z {\Ldecl T \Bot {p.B_c}}}\\
&}\ldefs{}}{}
\end{align*}

The glb is of $p.A_c$ and $p.B_c$ is $p.A_c \tand p.B_c$ by
definition.

\subsection{Expansion}

The expansion of $p.A_c \tand p.B_c$ is the set $\{\Ldecl T \Bot
{p.A_c \tand p.B_c}\}$ by \textsc{$\tand$-$\expand$} rule:

\

{\tiny
\prooftree
     p.A_c \expand_z \{\Ldecl T \Bot {p.A_c}\}\quad
     p.B_c \expand_z \{\Ldecl T \Bot {p.B_c}\}
\justifies
     p.A_c \tand p.B_c \expand_z \{\Ldecl T \Bot {p.A_c \tand p.B_c}\}
\using
     \textsc{$\tand$-$\expand$}
\endprooftree
}

\

In turn, $p.A_c \expand_z \{\Ldecl T \Bot {p.A_c}\}$ is derived as
follows:

\

{\tiny
\prooftree
   \[
   \ldots
   \justifies
   p \ni {\Ldecl {A_c} \Bot {\Top \refine z {\Ldecl T \Bot {p.A_c}}}}\quad
   \using
   \textsc{path-$\ni$}
   \]
   \[
   \[
   \justifies
   \Top \expand_z \{\}
   \using
   \textsc{$\Top$-$\expand$}
   \]
   \justifies
   {\Top \refine z {\Ldecl T \Bot {p.A_c}}} \expand_z \{\Ldecl T \Bot {p.A_c}\}
   \using
   \textsc{rfn-$\expand$}
   \]
\justifies
   p.A_c \expand_z \{\Ldecl T \Bot {p.A_c}\}
\using
     \textsc{tsel-$\expand$}
\endprooftree
}

Note that expansions do not always exist; see
section~\ref{narrowing_exp} for illustration.

\subsection{Functions as Sugar}
Like in Scala, we can encode functions as objects with a special
method. Note that the variable $z$ must be fresh.
\begin{align*}
\arrow S T &\iff {\Top \refine z {\mdecl {\mi{apply}} S T}}\\
\fun x S T t &\iff \new z {{\arrow S T}\ldefs{\mi{apply}(x) = t}} z\\
\app f x &\iff \mapp f {\mi{apply}} x\\
\cast T t&\iff \app {(\fun x T T x)} t
\end{align*}

We will freely use the following sugar in the remaining of this
paper. We will also sometimes use $\abs x S t$ for $\fun x S \_ t$,
omitting the return type for convenience and brevity.

\subsection{Class Hierarchies}
A class hierarchy such as
\begin{lstlisting}
object pets {
  trait Pet
  trait Cat extends Pet
  trait Dog extends Pet
  trait Poodle extends Dog
  trait Dalmatian extends Dog
}
\end{lstlisting}
can be easily represented by concrete type members, setting the upper
bounds appropriately:
\begin{align*}
\mlnew {\mi{pets}} {&\Top \mlrefine z {\\
&\ \Ldecl {\mi{Pet_c}} \Bot \Top\\
&\ \Ldecl {\mi{Cat_c}} \Bot {z.{\mi{Pet_c}}}\\
&\ \Ldecl {\mi{Dog_c}} \Bot {z.{\mi{Pet_c}}}\\
&\ \Ldecl {\mi{Poodle_c}} \Bot {z.{\mi{Dog_c}}}\\
&\ \Ldecl {\mi{Dalmatian_c}} \Bot {z.{\mi{Dog_c}}}\\
} \ldefs{}}{}
\end{align*}

The lower of bounds of $\Bot$ ensures that these concrete types are
nominal as the \textsc{$\sub$-tsel} rule cannot be meaningfully
applied.

\subsection{Abstract Type Members}
The \code{choices.Alt} trait takes three abstract type members:
\code{C}, \code{A}, \code{B}. \code{A} and \code{B} are upper bounded
by \code{C}. The intention is that the \code{choose} function takes an
\code{A} and a \code{B} and returns one or the other.
\begin{lstlisting}
object choices {
  trait Alt {
    type C
    type A <: C
    type B <: C
    val choose : A => B => C
  }
}
\end{lstlisting}
In DOT, we can state more precisely the return type of $\mi{choose}$,
thanks to union types:
\begin{align*}
&\new {\mi{choices}} {\Top \mlrefine z {\\
&\gap\Ldecl {\mi{Alt_c}} {\Bot} {\Top \mlrefine a {\\
&\gap\gap\Ldecl C \Bot \Top\\
&\gap\gap\Ldecl A \Bot {a.C}\\
&\gap\gap\Ldecl B \Bot {a.C}\\
&\gap\gap\mdecl {\mi{choose}} {a.A} {\arrow {a.B} {a.A \tor a.B}}\\
&\gap}}\\
&}\ldefs{}}{}
\end{align*}

Using lower bounds of $\Bot$ for the abstract type members means they
can vary covariantly. However, we wouldn't want to pass in any
${\mi{pets.Pet_c}}$ to a $\mi{choose}$ method that expects only a
${\mi{pets.Dog_c}}$. Therefore,
\begin{align*}
&{\mi{choices.Alt_c} \refine a {\Ldecl C \Bot {\mi{pets.Dog_c}}}}\\
\sub\gap&{\mi{choices.Alt_c} \refine a {\Ldecl C \Bot {\mi{pets.Pet_c}}}}
\end{align*}
but
\begin{align*}
&{\mi{choices.Alt_c} \refine a {\Ldecl C {\mi{pets.Dog_c}} {\mi{pets.Dog_c}}}}\\
\not\sub\gap&{\mi{choices.Alt_c} \refine a {\Ldecl C {\mi{pets.Pet_c}} {\mi{pets.Pet_c}}}}
\end{align*}

As expected, we cannot invoke $\mi{choose}$ meaningfully, unless $A$
and $B$ have realizable lower bounds. For example, assuming we refine
the types above so that $\Ldecl A C C$ and $\Ldecl B C C$, we cannot
invoke $\mi{choose}$ when $C$ has a lower bound of $\Bot$ but only
when it has a realizable lower bound such as $\mi{pets.Dog_c}$.

\subsection{Polymorphic Operators as Sugar}
In Scala, we can implement a polymorphic operator \code{pickLast}
which takes concrete types for \code{C}, \code{A} and \code{B} and
implements a \code{choices.Alt} instance where the \code{choose}
function picks the \code{B} element -- note the precision of the
\code{choose} function which has been refined to return an element of
exactly type \code{B}.
\begin{lstlisting}
def pickLast[Cp,Ap <: Cp,Bp <: Cp] = new Alt {
  type C = Cp
  type A = Ap
  type B = Bp
  val choose: A => B => B = a => b => b
}

val potty = new Poodle {}
val dotty = new Dalmatian {}
val picker = pickLast[Dog,Poodle,Dalmatian]
val p: picker.A = potty
val r: picker.B = picker.choose(potty)(dotty)
\end{lstlisting}

In DOT, we can implement such a polymorphic operator as sugar. Here,
it is not convenient to just return a complex term like we did for
functions as sugar because then invoking $\mi{choose}$ falls under the
$\textsc{term-$\ni$}$ restriction, which doesn't allow the ``self''
type to occur in the result of the method invocation. So the
translation involves explicitly binding an object to the result of the
polymorphic operator. We translate
\begin{align*}
\textbf{val } x^a = \textbf{pickLast}(T^C, T^A, T^B); e^a
\end{align*}
to
\begin{align*}
&\mlnew {x^a} {\mi{choices.Alt_c} \mlrefine {x^a} {\\
&\gap\Ldecl C {T^C} {T^C}\\
&\gap\Ldecl A {T^A} {T^A}\\
&\gap\Ldecl B {T^B} {T^B}\\
&\gap\mdecl {\mi{choose}} {x^a.A} {\arrow {x^a.B} {x^a.B}}\\
&}\ldefs{\mi{choose}(a)=\fun b {x^a.B} {x^a.B} b}}
{e^a}
\end{align*}

Now, given
\begin{align*}
&\mlnew p {\mi{pets.Poodle_c}}
{\mlnew d {\mi{pets.Dalmatian_c}}
{\textbf{val } a = \textbf{pickLast}({\mi{pets.Dog_c}}, {\mi{pets.Poodle_c}}, {\mi{pets.Dalmatian_c}});}}
\end{align*}

The type of $a$ is a subtype of ${\mi{choices.Alt_c}}$:
\begin{align*}
&\cast \Top {\\
&\cast {\mi{choices.Alt_c}} {\\
&\cast {{\mi{choices.Alt_c}} \refine a {\Ldecl C \Bot {\mi{pets.Dog_c}}}} {\\
&a}}}
\end{align*}

The type of $p$ is a subtype of $a.A$:
\begin{align*}
\cast \Top {\cast {a.A} {p}}
\end{align*}

$a$ chooses a $\mi{pets.Dalmatian_c}$:
\begin{align*}
\cast \Top {\cast {\mi{pets.Dalmatian_c}} {\app {a.choose(p)} d}}
\end{align*}

$a$ enforces that its first argument be a $\mi{pets.Poodle_c}$ and its second a $\mi{pets.Dalmatian_c}$. The following does not typecheck for this reason:
\begin{align*}
\cast \Top {\app {a.choose(d)} p}
\end{align*}

\subsection{F-bounded Quantification}

F-bounded quantification describes an upper bound that itself contains
the type being constrained: for example, \code{Int extends Ordered[Int]}.
Here, we define \code{MetaAlt} to extend
\code{choices.Alt} with \code{C} as an alias for \code{MetaAlt}.

\begin{lstlisting}
trait MetaAlt extends choices.Alt {
  type C = MetaAlt
  type A = C
  type B = C
}
\end{lstlisting}

Now, we can define some \code{MetaAlt} instances:
\begin{lstlisting}
val first = new MetaAlt {
  val choose: C => C => C = a => b => a
}
val last = new MetaAlt {
  val choose: C => C => C = a => b => b
}
val recfirst = new MetaAlt {
  val choose: C => C => C = a => b => a.choose(a)(b)
}
val reclast = new MetaAlt {
  val choose: C => C => C = a => b => b.choose(a)(b)
}
\end{lstlisting}

The equivalent in DOT is straightforward. We wrap $\mi{MetaAlt}$ in a
namespace, so that we can refer to it.
\begin{align*}
&\mlnew m {\Top \mlrefine m {\\
&\gap\Ldecl {\mi{MetaAlt_c}} {\Bot} {{\mi{choices.Alt_c}} \mlrefine a {\\
&\gap\gap\Ldecl C {\mi{m.MetaAlt_c}} {\mi{m.MetaAlt_c}}\\
&\gap\gap\Ldecl A {\mi{a.C}} {\mi{a.C}}\\
&\gap\gap\Ldecl B {\mi{a.C}} {\mi{a.C}}\\
&\gap}}\\
&}\ldefs{}}{}
\end{align*}

Now, we can create the equivalent of \code{first} ($f$), \code{last}
($l$), \code{recfirst} ($\mi{rf}$) and \code{reclast} ($\mi{rl}$):
\begin{align*}
&\mlnew f {{\mi{m.MetaAlt_c}}\mlldefs{\\
&\gap\gap\mi{choose}(a)=\fun b {\mi{m.MetaAlt_c}} {\mi{m.MetaAlt_c}} a}}{
\mlnew l {{\mi{m.MetaAlt_c}}\mlldefs{\\
&\gap\gap\mi{choose}(a)=\fun b {\mi{m.MetaAlt_c}} {\mi{m.MetaAlt_c}} b}}{
\mlnew {\mi{rf}} {{\mi{m.MetaAlt_c}}\mlldefs{\\
&\gap\gap\mi{choose}(a)=\fun b {\mi{m.MetaAlt_c}} {\mi{m.MetaAlt_c}} {\\
&\gap\gap\gap \app {{\mi{a.choose}}(a)} b}}}{
\mlnew {\mi{rf}} {{\mi{m.MetaAlt_c}}\mlldefs{\\
&\gap\gap\mi{choose}(a)=\fun b {\mi{m.MetaAlt_c}} {\mi{m.MetaAlt_c}} {\\
&\gap\gap\gap \app {{\mi{b.choose}}(a)} b}}}{
}}}}
\end{align*}

Given these definitions, here is a valid expression, which evaluates to $f$:
$\cast \Top {\app {{\mi{rf.choose}}(f)} l}$.

\section{Counterexamples to Preservation}\label{dot-preservation}

We sketch a proof that the DOT calculus is type-safe using logical
relations in section~\ref{dot-type-safety}. However, we first tried to
prove the calculus type-safe using the standard theorems of
preservation and progress~\cite{soundness,tapl}. Unfortunately, for
the calculus as presented, and any of its variants that we devised,
preservation doesn't hold. In this section, we review some of the most
salient counterexamples to preservation that we found. These
counterexamples have been checked with PLT Redex~\cite{plt_redex}.

Most of these counterexamples are related to narrowing, the phenomenon
that a type can become more precise after substitution: if a method
takes a parameter $x$ of type $U$, then when it is invoked, any
argument $v$ of type $S \sub U$ can be substituted -- this is the
narrowing effect: it is as if the context was changed from $x : U$ to
$x : S$. Sections~\ref{term_mem},~\ref{narrowing_exp}~and~\ref{narrowing_wf} each
present a counterexample related to narrowing.

The last counterexample, presented in section~\ref{patheq},
illustrates the need to relate path-dependent types after
reduction. This need for path-equality provisions in order for
preservation to hold is well-known from other calculi such as
Tribe~\cite{tribe} with path-dependent types and a small-step
operational semantics.

More generally, these counterexamples illustrate that preservation
doesn't hold because a term that typechecks can step to a term that
does not typecheck. However, these counterexamples to preservation are
not counterexamples to type-safety: i.e. these programs don't get
stuck -- they eventually step to a value.

\subsection{\texorpdfstring{\textsc{term-$\ni$}}{Term-Mem} Restriction}\label{term_mem}

There are two membership ($t \ni D$) rules: one for when the term $t$
is a path, and one for an arbitrary term $t$. For paths, we can
substitute the self-references in the declarations, but we cannot do
so for arbitrary terms as the resulting types wouldn't be well-formed
syntactically. Hence, the $\textsc{term-$\ni$}$ has the restriction
that self-occurrences are not allowed. Here is a counterexample related
to this restriction.

Let $X$ be a shorthand for the type:
\begin{align*}
\Top & \mlrefine z {\\
&\ \Ldecl {L_a} \Top \Top\\
&\ \ldecl l {z.L_a}\\
}&
\end{align*}

Let $Y$ be a shorthand for the type:
\begin{align*}
\Top & \mlrefine z {\\
&\ \ldecl l \Top\\
}&
\end{align*}

Now, consider the term
\begin{align*}
&\mlnew u {X \ldefs{ l = u }}{
\app {(\abs y {\Top \tfun Y} {\app y u})} {(\abs d \Top {\cast X u})}.l
}
\end{align*}

The term type-checks because the term $t=\app {(\abs y {\Top \tfun Y}
  {\app y u})} {(\abs d \Top {\cast X u})}$ has type
$Y$, so we can apply $\textsc{term-$\ni$}$ for $l$. However, the term
$t$ eventually steps to ${\cast X u}$ which has type $X$,
so we cannot apply $\textsc{term-$\ni$}$ for $l$ because of the
self-reference ($z.L_a$).

\subsection{Expansion Lost}\label{narrowing_exp}

First, let's illustrate why expansion does not always exist.

Here is the simplest such example:
\begin{align*}
&\mlnew z {\Top \mlrefine z {\\
&\gap \Ldecl {L} \Bot {z.L}\\
&}\ldefs{}}{}
\end{align*}
The type $z.L$ is $\nswf$ but not $\nswfe$. Indeed, there is no finite
derivation of an expansion for $z.L$, because by the
$\textsc{tsel-$\expand$}$ rule, in order to expand $z.L$, we need to
expand its upper bound, which is $z.L$! However, not that the object
creation expression for $z$ would not typecheck because subtyping is
regular wrt $\nswfe$, and so the type of a constructor in an object
creation expression must have $\nswfe$ type members, since we check
that the lower bound is a subtype of the upper bound for each type
member.

The example above relies on the $\textsc{tsel-wf$_2$}$, in order for
the upper bound to refer to the type member being declared. Here is an
example that does not rely on this rule, and that we will use below to
create a counterexample to preservation. Let
\begin{align*}
T_1 = \Top &\mlrefine z {&\\
&\gap\Ldecl A \Bot {z.B}&\\
&\gap\Ldecl B \Bot \Top&}\\
T_2 = \Top &\mlrefine z {&\\
&\gap\Ldecl A \Bot \Top&\\
&\gap\Ldecl B \Bot {z.A}&}
\end{align*}

Now, consider $T_1 \tand T_2$. The type is $\nswf$ and $\nswfe$, but
its members $A$ and $B$ are not $\nswfe$, because the expansion of
$T_1 \tand T_2$ with self-type $z$ has the set of declarations
$\{\Ldecl A \Bot {z.B},\;\Ldecl B \Bot {z.A}\}$ -- thus, to expand
$z.A$, we need to expand $z.B$, and to expand $z.B$, we need to expand
$z.A$! There is no finite derivation of expansions for the type
members $A$ and $B$.

Expansion is not preserved by narrowing. Here, we create two type
selections that are mutually recursive in their upper bounds after
narrowing: $z_0.C_2$ initially expands, but after narrowing, $z_0.C_2$
expands to what $z_0.A_2$ expands to, which expands to what $z_0.A_1$
expands to, which expands to what $z_0.A_2$ expands to, and thus we
have an infinite expansion. Thus, the last new expression initially
type-checks, but after narrowing, it doesn't because the precise
expansion needed by $\textsc{new}$ cannot be inferred.

\begin{align*}
&\mlnew {x_0} {\Top \mlrefine z { \Ldecl {A_1} \Bot {\Top \mlrefine z {\\
&\gap\Ldecl {A_2} \Bot \Top\\
&\gap\Ldecl {A_3} \Bot \Top\\
&\gap\Ldecl {C_2} \Bot {z.A_2}}}}\ldefs{}}{
\mlnew {x_1} {\Top \refine z {\Ldecl {C_1} \Bot {\Top \refine z {\Ldecl {A_1} \Bot {x_0.A_1}}}}\ldefs{}}}{
\mlnew {x_2} {{x_1.C_1} \refine z {\Ldecl {A_1} \Bot {{x_0.A_1} \refine z {\Ldecl {A_2} \Bot {z.A_3}}}}\ldefs{}}}{
\mlnew {x_3} {{x_1.C_1} \refine z {\Ldecl {A_1} \Bot {{x_0.A_1} \refine z {\Ldecl {A_3} \Bot {z.A_2}}}}\ldefs{}}}{
\mlapp {\abs x {x_1.C_1} {(\abs {z_0} {x.A_1 \tand x_3.A_1} {\\&\gap\gap\gap\new z {z_0.C_2} {\app {(\abs x \Top x)} z}})}} {\ x_2}}
\end{align*}

\subsection{Well-Formedness Lost}\label{narrowing_wf}

Even well-formedness is not preserved by narrowing. The trick is that
if the lower bound of a type selection is not $\Bot$, then the
bounds needs to be checked for well-formedness. Here, we create two
type selections that are mutually recursive in their bounds
after narrowing. $y.A$ is initially well-formed, but after narrowing,
it isn't because we run into an infinite derivation trying to prove
the well-formedness of its bounds.

\begin{align*}
&\mlnew v {\Top \refine z {\Ldecl L \Bot {\Top \refine z {\Ldecl A \Bot \Top, \Ldecl B {z.A} {z.A}}}} \ldefs{}}{
\mlapp {(\abs x {\Top \refine z {\Ldecl L \Bot {\Top \refine z {\Ldecl A \Bot \Top, \Ldecl B \Bot \Top}}}} {\\&\gap
\mlnew z {\Top \mlrefine z {\\&\gap\gap\gap
\mdecl l {x.L \tand {\Top \refine z {\Ldecl A {z.B} {z.B}, \Ldecl B \Bot \Top}}} \Top}\mlldefs{\\&\gap\gap\gap
l(y) = \fun a {y.A} \Top a}}{
\gap \cast {\top} z
}})}{\ v}}
\end{align*}

\subsection{Path Equality}\label{patheq}

For preservation, we need to be able to relate path-dependent types
after reduction. Here is a motivating example:

\begin{align*}
&\mlnew b {\Top \mlrefine z {&&\Ldecl X \Top \Top&\\
&&&\ \ldecl l {z.X}&}\ldefs{l = b}}{
\mlnew a {\Top \mlrefine z {\ldecl i {\Top \mlrefine z {&&&\\
&&&\Ldecl X \Bot \Top\\
&&&\ldecl l {z.X}}}&}\ldefs{i = b}}}{
\app {(\abs x \Top x)} {\app {(\abs x {a.i.X} x)} {a.i.l}}}
\end{align*}

$a.i.l$ reduces to $b.l$. $b.l$ has type $b.X$, so we need $b.X <:
a.i.X$. This cannot be established with the current rules: it is not
true in general, but true here because $a.i$ reduces to $b$. Hence,
we need to acknowledge path equality for preservation to hold.

In section~\ref{pres-patch}, we discuss our failure to patch the
calculus for preservation to hold.

\section{Discussion}\label{discussion}

\subsection{Why No Inheritance?}\label{why-no-inheritance}

In the calculus we made the deliberate choice not to model any form of
inheritance. This is, first and foremost, to keep the calculus simple.
Secondly, there are many different approaches to inheritance and
mixin composition, so that it looks advantageous not to tie the basic
calculus to a specific one. Finally, it seems that the modelization of
inheritance lends itself to a different approach than the basic
calculus. For the latter, we need to prove type safety of the calculus.
One might try to do this also for a calculus with inheritance, but our
experience suggests that this complicates the proofs considerably.  An
alternative approach that might work better is to model inheritance
as a form of code-reuse. Starting with an enriched type system with
inheritance, and a translation to the basic calculus, one needs to
show type safety wrt the translation. This might be easier than
to prove type safety wrt reduction.

\subsection{Variants of the DOT Calculus}\label{dot-variants}

\subsubsection{Why limit the calculus to $\nswfe$-types?}\label{dot-variants-why-wfe}

Currently, the proof of type-safety via logical relations
fundamentally relies on types having an expansion. However, this was
not our original motivation for limiting the calculus to $\nswfe$-types.

Originally, subtyping was not regular wrt $\nswfe$. Roughly,
all the $\nswfe$ preconditions in subtyping were dropped. In this
broader calculus, subtyping transitivity doesn't hold, because of the
rule (\textsc{$\sub$-rfn}) which requires expansion of the left type.

The problem is deep, as attested by this elaborate counterexample
that is not so easily patched, and directly leads to a counterexample
to preservation.

Consider an environment where $u$ is bound to:
\begin{align*}
\Top & \mlrefine u {\\
&\ \Ldecl {\mathit{Bad}} {\Bot} {u.\mathit{Bad}}\\
&\ \Ldecl {\mathit{Good}} {\Top \refine z {\Ldecl L \Bot \Top}} {\Top \refine z {\Ldecl L \Bot \Top}}\\
&\ \Ldecl {\mathit{Lower}} {u.\mathit{Bad} \tand u.\mathit{Good}} {u.\mathit{Good}}\\
&\ \Ldecl {\mathit{Upper}} {u.\mathit{Good}} {u.\mathit{Bad} \tor u.\mathit{Good}}\\
&\ \Ldecl X {u.\mathit{Lower}} {u.\mathit{Upper}}\\
}&
\end{align*}

Now, consider the types $S$, $T$, $U$ defined in terms of $u$:
\begin{align*}
S &= u.\mathit{Bad} \tand u.\mathit{Good}\\
T &= u.\mathit{Lower}\\
U &= u.X \refine z {\Ldecl L \Bot \Top}
\end{align*}
We have $S \sub T$ and $T \sub U$, but we cannot derive $S \sub U$ because
$S$ doesn't expand.

Note that $u$ is realizable, since each lower bound is a subtype of
its upper bound. So it is straightforward to turn this counterexample
to subtyping transitivity into a counterexample to preservation:
\begin{align*}
&\mlnew u \ldots {
\ \mlapp{\abs x \Top x}{
\ \ \mlapp{\abs f {S \tfun U} f}{
\ \ \ \mlapp{\abs f {S \tfun T} f}{
\ \ \ \ \mlapp{\abs f {S \tfun S} f}{
\ \ \  \ \ \abs x S x}}}}}
\end{align*}

The idea is to start with a function from $S \tfun S$ and cast it
successively to $S \tfun T$ then $S \tfun U$. To typecheck the
expression initially, we need to check $S \sub T$ and $T \sub
U$. After some reduction steps, the first few casts vanish, and the
reduced expression casts directly from $S \tfun S$ to $S \tfun U$, so
we need to check $S \sub U$.

\subsubsection{Why not include the lambda-calculus instead of methods?}

Originally, the DOT calculus included the lambda-calculus, and
explicit methods were not needed since they could be represented by a
value label with a function type. However, the expansion of the
function type was defined to be the empty set of declarations (like
for $\Top$), which caused a real breach of type-safety.

A concrete object could be a subtype of a function type without a
function ever being defined. Consider:
\begin{align*}
&\mlnew u {\Top \refine z {\Ldecl C {\Top \tfun \Top} {\Top \tfun \Top}} \ldefs{}} {
\mlnew f {u.C \ldefs{}} {
\ldots
}}
\end{align*}

Now, $f$ was a subtype of $\Top \tfun \Top$, but $\app f {(\abs x \Top
  x)}$ was stuck (and, rightfully, didn't typecheck). But we could use
narrowing to create a counterexample to type safety: $\app {(\abs g
  {\Top \tfun \Top} {\app g (\abs x \Top x)})} f$.

Because of this complication, we decided to drop the lambda-calculus
from DOT, and instead introduce methods with one parameter. Like in
Scala, functions are then just sugar for objects with a special
method.

An alternative design would have been to change the expansion of the
function type to have a declaration for a special label that either
prevents instantiation or requires an implementation for the
function.

\subsubsection{Why not patch the DOT calculus for preservation to hold?}\label{pres-patch}

We tried! However, the resulting calculi were not elegant, and
furthermore, we still found issues with preservation. Below, we give a
brief summary of one failed attempt to patch the calculus for
preservation to hold.

Because many of the counterexamples to preservation are related to
narrowing, we tried to make widening an explicit operation and change
rules with implicit relaxations (\textsc{msel} and \textsc{new}) to be
strict. From a typing perspective, the change was straightforward, but
reduction became more complicated and dependent on typing because the
type information in widenings needed to be propagated correctly.

We added path equality provisions in the subtyping rules, in the same
spirit as the Tribe calculus~\cite{tribe}.

Unfortunately, these two patches interacted badly, and we were left
with a disturbing counterexample to type safety.

\begin{align*}
&\mlnew a {\Top \refine z {\Ldecl C \Bot {\Top \refine z {\Ldecl D \Bot {z.X}, \Ldecl X \Bot \Top}}}}{
\mlnew b {{a.C} \refine z {\Ldecl X \Bot \Bot}}}{
\mlnew c {a.C}}{
\mlnew d {{\cast {a.C} b}.D}}{
\app {(\abs x \Bot {x.\mathit{foo}})} d
}
\end{align*}

Notice that $d$ has type $\Bot$ if the cast on $b$ is ignored. This
example didn't typecheck initially because the path-equality
provisions only applied when objects are in the store, so the
application was not well-typed. But if we started preservation in a store
which had $a$, $b$, $c$ and $d$ then the application type-checked,
because, through one of the path-equality provision, we could find that
the type of $d$ was a subtype of $\Bot$. Now, of course, when we got to
$d.\mathit{foo}$, reduction failed.

\subsection{Related Work}

In addition to Scala's previous models~\cite{nuObj,FS}, several
calculi present some form of path-dependent types.

The {\it vc} calculus~\cite{vc} models virtual classes with
path-dependent types. {\it vc} restricts paths to start with ``this'',
though it provides a way (``out'') to refer to the enclosing object.

The Tribe calculus~\cite{tribe} builds an ownership types
system~\cite{tribalo} on top of a core calculus which models virtual
classes. The soundness proof for the core calculus seems to be tied to
the ownership types system.

Some ML-style module systems~\cite{homl,mixinml} have a form of
stratified path-dependent types. Because of the stratification,
recursion is not allowed. In MixML~\cite{mixml} like in Scala, this
restriction is lifted.

\section{Conclusion}\label{conclusion}

We have presented DOT, a calculus aimed as a new foundation of Scala
and languages like it. DOT features path-dependent types, refinement
types, and abstract type members.

Proving the DOT calculus type-safe has been an interesting
adventure. We have shown that DOT does not satisfy preservation (also
known as subject-reduction). However, the standard theorems of
preservation and progress are just one way to prove type safety. We
have sketched a plausible proof of type safety using the powerful
method of logical relations.

%\section{Examples}
%TODO: WIP
%
%\includegraphics[scale=0.7]{../../src/redex/ex_glb}

%\appendix
%\section{Appendix Title}

\acks

We thank Amal Ahmed for many discussions and insights about applying
logical relations to DOT. We thank Donna Malayeri and Geoffrey
Washburn for preliminary work on DOT. We thank Tiark Rompf and Viktor
Kuncak for helpful comments.

\bibliographystyle{abbrvnat}
\bibliography{dot}

\end{document}
