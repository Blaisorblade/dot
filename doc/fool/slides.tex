\documentclass{beamer}

\input{dot_macros}

\usepackage{minted}
\usemintedstyle{eclipse}

\useoutertheme{infolines}
\setbeamertemplate{headline}{}
\setbeamertemplate{footline}{
  \hfill
  \usebeamercolor[fg]{page number in head/foot}
  \usebeamerfont{page number in head/foot}
  \insertpagenumber\kern1em\vskip10pt
}
\setbeamertemplate{navigation symbols}{}

\title{Dependent Object Types}
\subtitle{Towards a foundation for Scala's type system}
\author{Nada Amin, Adriaan Moors, Martin Odersky}
\institute{FOOL 2012}
\date{October 22, 2012}

\begin{document}

\frame{\titlepage}

\section{Introduction}

\begin{frame}
\frametitle{DOT: Dependent Object Types}

The DOT calculus proposes a new \emph{type-theoretic foundation} for Scala
and languages like it. It models
\begin{itemize}
\item path-dependent types
\item abstract type members
\item mixture of nominal and structural typing via refinement types
\end{itemize}

It does not model
\begin{itemize}
\item inheritance and mixin composition
\item what's currently in Scala
\end{itemize}

DOT normalizes Scala's type system by
\begin{itemize}
\item unifying the constructs for type members
\item providing classical intersection and union types
\end{itemize}

\end{frame}

\section{Differences with Scala}

\begin{frame}[fragile]{Classicial Intersection and Union Types}
\begin{itemize}
\item form a lattice wrt subtyping
\item simplify glb and lub computations
\end{itemize}
\begin{minted}{scala}
  trait A { type T <: A }
  trait B { type T <: B }
  // in Scala, glb is an infinite sequence
  A with B { type T <: A with B { type T <: A with B {
    type T <: ...
  }}}
  // in DOT, glb is simply A /\ B
  // type inference needs to compute glbs and lubs
  if (cond) ((a: A) => c: C) else ((b: B) => d: D)
  // glb(A, B) => lub(C, D)
\end{minted}

\end{frame}

\begin{frame}[fragile]{Constructs for Type Memers}
\begin{minted}{scala}
trait Food
trait Animal {
  // in DOT, Meal: Bot .. Food
  type Meal <: Food
  def eat(meal: Meal) {}
}

trait Grass extends Food
trait Cow extends Animal {
  // in DOT, Meal: Grass .. Grass
  type Meal = Grass
}
\end{minted}
\end{frame}

\section{Formalities}

\begin{frame}[fragile]{DOT: Syntax}
\begin{itemize}
\item terms
\begin{description}[method invocations]
\item[variables] $x$, $y$, $z$
\item[selections] $t.l$
\item[method invocations] $t.m(t)$
\item[object creations] $\new y c {t'}$\\
$c$ is a constructor $T_c \ldefs{\seq{l = v}\;\seq{m(x) = t}}$
\end{description}
\item types
\begin{description}[type intersections]
\item[type selections] $p.L$
\item[refinement types] $T \refine z {\seq D}$
\item[type intersections] $T \tand T'$
\item[type unions] $T \tor T'$
\item[a top type] $\Top$
\item[a bottom type] $\Bot$
\end{description}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{DOT: Judgments}
\begin{columns}
\begin{column}[t]{5cm}
\begin{block}{Typing Judgments}
\begin{itemize}
\item type assignment\\$\Gamma \ts t \typ T$
\item subtyping\\$\Gamma \ts S \sub T$
\item well-formedness\\$\Gamma \ts T \wf$
\item membership\\$\Gamma \ts t \ni D$
\item expansion\\$\Gamma \ts T \expand_z \seq{D}$
\end{itemize}
\end{block}
\end{column}
\begin{column}[t]{5cm}
\begin{block}{Small-Step Operational Semantics}
\begin{itemize}
\item reduction\\$\reduction t s {t'} {s'}$
\end{itemize}
\end{block}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Example: Class Hierarchies}
\begin{minted}[fontsize=\footnotesize]{scala}
object pets {
  trait Pet
  trait Cat extends Pet
  trait Dog extends Pet
  trait Poodle extends Dog
  trait Dalmatian extends Dog
}
\end{minted}
\begin{align*}
\mlnew {&\mi{pets}} {\Top \mlrefine z {\\
&\ \Ldecl {\mi{Pet_c}} \Bot \Top\\
&\ \Ldecl {\mi{Cat_c}} \Bot {z.{\mi{Pet_c}}}\\
&\ \Ldecl {\mi{Dog_c}} \Bot {z.{\mi{Pet_c}}}\\
&\ \Ldecl {\mi{Poodle_c}} \Bot {z.{\mi{Dog_c}}}\\
&\ \Ldecl {\mi{Dalmatian_c}} \Bot {z.{\mi{Dog_c}}}\\
} \ldefs{}}{}
\end{align*}
\end{frame}

\begin{frame}[fragile]
\frametitle{Example: Abstract Type Members}
\begin{minted}[fontsize=\footnotesize]{scala}
object choices {
  trait Alt {
    type C
    type A <: C
    type B <: C
    val choose : A => B => C
  }
}
\end{minted}
\begin{align*}
&\new {\mi{choices}} {\Top \mlrefine z {\\
&\gap\Ldecl {\mi{Alt_c}} {\Bot} {\Top \mlrefine a {\\
&\gap\gap\Ldecl C \Bot \Top\\
&\gap\gap\Ldecl A \Bot {a.C}\\
&\gap\gap\Ldecl B \Bot {a.C}\\
&\gap\gap\mdecl {\mi{choose}} {a.A} {\arrow {a.B} {a.A \tor a.B}}\\
&\gap}}\\
&}\ldefs{}}{}
\end{align*}
\end{frame}

\end{document}
