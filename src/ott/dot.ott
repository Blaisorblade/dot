metavar x, y, z        ::= {{ com Variable }}
{{ coq nat }} {{ coq-equality }}
metavar l              ::= {{ com Value label }}
{{ coq nat }} {{ coq-equality }}
metavar Lc {{ tex L_c }} ::= {{ com class label }}
{{ coq nat }} {{ coq-equality }}
metavar La {{ tex L_a }} ::= {{ com abstract type label }}
{{ coq nat }} {{ coq-equality }}

indexvar index, i, j, n ::=
{{ coq nat }}

grammar
v :: v_                ::= {{ com Value }}
  | x                  :: :: Variable {{ com variable }}

t :: t_                ::= {{ com Term }}
  | x                  :: :: Variable {{ com value }}
  | val x = new c ; t  :: :: NewInstance {{ com new instance }}
  | t l t'             :: :: Selection {{ com selection }}
  | ( t )              :: S:: Paren {{ icho [[t]] }}
  | [ t / x ] t'       :: M:: Sub {{ icho (tsubst_t [[t]] [[x]] [[t']]) }}
  | e [ t ]            :: M:: Ctx {{ icho (appctx_e_t [[e]] [[t]]) }}

p :: p_                ::= {{ com Path }}
  | x                  :: :: Variable
  | val x = new c ; p  :: :: NewInstance
  | p l p'             :: :: Selection

c :: c_                ::= {{ com Constructor }}
  | Tc { l0 ( x0 : T0 ) = t0 , .. , ln ( xn : Tn ) = tn } :: :: Constructor

G {{ tex \Gamma }} :: G_ ::=  {{ coq list (x*T) }} {{ com Environment }}
  | []                 :: :: Nil
   {{ coq G_nil }}
  | G , x : T          :: :: Cons
   {{ coq (cons ([[x]],[[T]]) [[G]]) }}

s :: s_                ::=  {{ coq list (x*c) }} {{ com Store }}
  | []                 :: :: Nil
   {{ coq s_nil }}
  | s , x |-> c        :: :: Cons
   {{ coq (cons ([[x]],[[c]]) [[s]]) }}

L :: L_                ::= {{ com Type label }}
  | Lc                 :: :: Class
  | La                 :: :: Abstract

T, S {{ coq St }}, U, V, W :: T_ ::= {{ com Type }}
  | p . L              :: :: TypeSelection {{ com type selection }}
  | p . La             :: :: AbstractTypeSelection
  | p . Lc             :: :: ClassTypeSelection
  | T { z => Dseq }    :: :: Refinement {{ com refinement }}
  | T /\ T'            :: :: Intersection {{ com intersection type }}
  | T \/ T'            :: :: Union {{ com union type }}
  | Top                :: :: Top {{ com top type }}
  | Bottom             :: :: Bottom {{ com bottom type }}

Tc {{ tex T_c }}, Sc {{ tex S_c }} :: Tc_ ::= {{ com Concrete Type }}
  | p . Lc             :: :: ClassTypeSelection
  | Tc { z => Dseq }   :: :: Refinement
  | Tc /\ Tc'          :: :: Intersection
  | Top                :: :: Top

D :: D_                ::= {{ com Declaration }}
  | L : S '..' U       :: :: Type {{ com type declaration }}
  | l : S -> T         :: :: Term {{ com term declaration }}
  | [ t / x ] D        :: M:: Sub {{ icho (tsubst_D [[t]] [[x]] [[D]]) }}

Dseq {{ tex \overline{D} }} :: Dseq_ ::=
  | {}                 :: S:: Empty
   {{ coq (Dseq_Seq nil) }}
  | </ Di // , // i /> :: :: Seq
  | Dseq /\ Dseq'      :: M:: And
   {{ coq [[Dseq]] }} % TODO
  | Dseq \/ Dseq'      :: M:: Or
   {{ coq [[Dseq]] }} % TODO
  | DseqBottom         :: M:: Bottom {{ tex \overline{D_\bot} }}
   {{ coq (Dseq_Seq nil) }} % TODO

e :: e_                ::= {{ com Context }}
  | __ l t             :: :: SelLeft
  | v l __             :: :: SelRight

terminals :: terminals_ ::=
  | |->                :: :: mapsto {{ tex \mapsto }}
  | ->                 :: :: rightarrow {{ tex \rightarrow }}
  | -->                :: :: longrightarrow {{ tex \;\longrightarrow\; }}
  | =>                 :: :: Rightarrow {{ tex \Rightarrow }}
  | \/                 :: :: tand {{ tex \wedge }}
  | /\                 :: :: tor {{ tex \vee }}
  | Top                :: :: top {{ tex \top }}
  | Bottom             :: :: bot {{ tex \bot }}
  | __                 :: :: hole {{ tex [\,] }}
  | in                 :: :: in {{ tex \in }}
  | mem                :: :: mem {{ tex \ni }}
  | |-                 :: :: ts {{ tex \,\vdash\, }}
  | |=                 :: :: ms {{ tex \,\models\, }}
  | fn                 :: :: fn {{ tex \text{\sl fn} }}
  | notin              :: :: notin {{ tex \not\in }}

formula :: formula_    ::=
  | judgement          :: :: judgement
  | x |-> c in s       :: :: StoreLookup
    {{ coq (store_bound [[x]] [[c]] [[s]]) }}
  | x : T in G         :: :: EnvLookup
    {{ coq (env_bound [[x]] [[T]] [[G]]) }}
  | x notin fn ( T )   :: :: NotFreeCheck
    {{ coq (~In [[x]] (fv_T [[T]])) }}
  | formula1 .. formulan :: :: dots

embed
{{ coq
Notation G_nil := (@nil (x*T)).
Definition env_bound x0 T0 G :=
  exists G1, exists G2,
    (G = List.app G1 (List.cons (x0,T0) G2)) /\
    ~In x0 (List.map (@fst x T) G1).
Notation s_nil := (@nil (x*c)).
Definition store_bound x0 c0 s :=
  exists s1, exists s2,
    (s = List.app s1 (List.cons (x0,c0) s2)) /\
    ~In x0 (List.map (@fst x c) s1).
}}

subrules
  v  <:: t
  v  <:: p
  p  <:: t
  Tc <:: T

contextrules
  e _:: t :: t

substitutions
  single t x :: tsubst

freevars
  t x :: fv

defns
Job :: '' ::=

 defn
 t | s --> t' | s' :: ::reduce:: red_ {{ com Reduction }} by


 --------------------------------------- :: New
 val x = new c; t | s --> t | s, x |-> c


 x |-> Tc { l0(x0:T0)=t0, .., ln(xn:Tn)=tn } in s
 ------------------------------------------------ :: Sel
 x li v | s --> [v/xi] ti | s

 t | s --> t' | s'
 ----------------------- :: Ctx
 e[t] | s --> e[t'] | s'

 defn
 G , s |- t : T :: ::typing:: typ_ {{ com Type Assignment }} by

 x : T in G
 ------------- :: Var
 G, s |- x : T

 G, s |- t1 mem l1 : S1 -> T1
 G, s |- t2 : T2
 G, s |- T2 <: S1
 ----------------------------------------------- :: Sel
 G, s |- t1 l t2 : T1

 x notin fn(T)
 G, s |- Tc wfe
 G, s |- Tc expands x </ Lj : Sj .. Uj // j/>, </ li : Vi -> Wi // i/>
 </ G, x : Tc, s |- Ti wfe // i/>
 </ G, x : Tc, s |- Vi <: Ti // i/>
 </ G, x : Tc, s |- Sj <: Uj // j/>
 G, x : Tc, s |- t : T
 </ G, x : Tc, xi : Ti, s |- ti : Wi' // i/>
 </ G, x : Tc, xi : Ti, s |- Wi' <: Wi // i/>
 --------------------------------------------------------------------- :: New
 G, s |- val x = new Tc { </ li(xi:Ti)=ti // i/> }; t : T

 defn
 G , s |- t mem D :: ::membership:: mem_ {{ com Membership }} by

 G, s |- p : T
 G, s |- T expands z </ Di // i />
 --------------------------------------- :: Path
 G, s |- p mem [p/z] Di

 defn
 G , s |- T expands z Dseq :: ::expansion:: exp_ {{com Expansion }} {{ tex [[G]], [[s]] [[|-]] [[T]] \prec_[[z]] [[Dseq]] }} by

 G, s |- T expands z Dseq'
 ----------------------------------------------- :: Rfn
 G, s |- T { z => Dseq } expands z Dseq /\ Dseq'

 G, s |- T1 expands z Dseq1
 G, s |- T2 expands z Dseq2
 ----------------------------------------- :: And
 G, s |- T1 /\ T2 expands z Dseq1 /\ Dseq2

 G, s |- T1 expands z Dseq1
 G, s |- T2 expands z Dseq2
 ----------------------------------------- :: Or
 G, s |- T1 \/ T2 expands z Dseq1 \/ Dseq2

 G, s |- p mem L : S .. U
 G, s |- U expands z Dseq
 -------------------------- :: Sel
 G, s |- p.L expands z Dseq


 ------------------------ :: Top
 G, s |- Top expands z {}


 ----------------------------------- :: Bot
 G, s |- Bottom expands z DseqBottom

 defn
 G , s |- S <: T :: ::subtyping:: sub_ {{com Subtyping }} by


 -------------- :: Refl
 G, s |- T <: T

 G, s |- S <: T
 G, s |- S expands z Dseq'
 G, z : S, s |- Dseq' <: Dseq
 ---------------------------- :: RfnR
 G, s |- S <: T { z => Dseq }

 G, s |- T <: T'
 ----------------------------- :: RfnL
 G, s |- T { z => Dseq } <: T'

 G, s |- p mem L : S .. U
 G, s |- S <: U
 G, s |- S' <: S
 ------------------------- :: TselR
 G, s |- S' <: p.L

 G, s |- p mem L : S .. U
 G, s |- S <: U
 G, s |- U <: U'
 ------------------------- :: TselL
 G, s |- p.L <: U'

 G, s |- T <: T1
 G, s |- T <: T2
 --------------------- :: AndR
 G, s |- T <: T1 /\ T2

 G, s |- Ti <: T
 --------------------- :: AndL
 G, s |- T1 /\ T2 <: T

 G, s |- T <: Ti
 --------------------- :: OrR
 G, s |- T <: T1 \/ T2

 G, s |- T1 <: T
 G, s |- T2 <: T
 --------------------- :: OrL
 G, s |- T1 \/ T2 <: T


 ---------------- :: TopR
 G, s |- T <: Top


 ------------------- :: BottomL
 G, s |- Bottom <: T

 p1 | s --> p2 | s'
 G, s |- T <: p2.L
 ------------------ :: PathRedR
 G, s |- T <: p1.L

 defn
 G , s |- D <: D' :: ::dsub:: dsub_ {{com Declaration subsumption }} by

 G, s |- S' <: S
 G, s |- U <: U'
 --------------------------------- :: Type
 G, s |- L : S .. U <: L : S' .. U'

 G, s |- S' <: S
 G, s |- T <: T'
 --------------------------------- :: Value
 G, s |- l : S -> T <: l : S' -> T'

 defn
 G , s |- Dseq <: Dseq' :: ::dseq_sub:: dseq_sub by

 defn
 G , s |- T wf :: ::wf:: wf_ {{com Well-formed types }} by

 G, s |- T wfe
 G, z : T { z => Dseq }, s |- Dseq wf
 ------------------------------------ :: Rfn
 G, s |- T { z => Dseq } wf

 G, s |- p mem L : S .. U
 G, s |- S wfe
 G, s |- U wfe
 ------------------------- :: TSel1
 G, s |- p.L wf

 G, s |- p mem L : Bottom .. U
 ----------------------------- :: TSel2
 G, s |- p.L wf

 G, s |- T wfe
 G, s |- T' wfe
 ------------------ :: And
 G, s |- T /\ T' wf

 G, s |- T wfe
 G, s |- T' wfe
 ------------------ :: Or
 G, s |- T \/ T' wf


 ------------------ :: Bot
 G, s |- Bottom wf


 -------------- :: Top
 G, s |- Top wf

 defn
 G , s |- D wf :: ::dwf:: dwf_ {{com Well-formed declarations }} by

 G, s |- S wfe
 G, s |- U wfe
 --------------------------------- :: Type
 G, s |- L : S .. U wf

 G, s |- S wfe
 G, s |- T wfe
 --------------------------------- :: Value
 G, s |- l : S -> T wf

 defn
 G , s |- Dseq wf :: ::dseq_wf:: dseq_wf by

 defn
 G , s |- T wfe :: ::wfe:: wfe_ {{com Well-formed and expanding types }} by

 G, s |- T wf
 G, s |- T expands z Dseq
 ------------------------ :: All
 G, s |- T wfe

 defn
 G |= s :: ::ctx:: ctx_ {{com Consistent Context }} by

