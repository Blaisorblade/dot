metavar var, x, y, z ::= {{ com Variable }}
{{ coq nat }} {{ coq-equality }} {{ ocaml string }} {{ ocamlvar "[[var]]" }} {{ lex alphanum }}
metavar label ::= {{ com Label }}
{{ coq nat }} {{ coq-equality }} {{ ocaml string }} {{ ocamlvar "[[label]]" }} {{ lex alphanum }}
indexvar index, i, j, n ::=
{{ coq nat }} {{ ocaml int }} {{ lex numeral }}

grammar
vlabel, l :: vlabel_   ::= {{ com Value label }}
  | label _v           :: :: any {{ tex [[label]] }}

clabel, Lc {{ tex {L_c} }} {{ ocaml tLc }} :: clabel_ ::= {{ com class label }}
  | label _c           :: :: any {{ tex {[[label]]}_c }}

alabel, La {{ tex {L_a} }} {{ ocaml tLa }} :: alabel_ ::= {{ com abstract type label }}
  | label _a           :: :: any {{ tex {[[label]]}_a }}

v :: v_                ::= {{ com Value }}
  | x                  :: :: var {{ com variable }}

tm, t :: Tm_           ::= {{ com Term }}
  | x                  :: :: var {{ com value }}
  | val x = new c ; t  :: :: new {{ com new instance }}
  | t l t'             :: :: sel {{ com selection }}
  | ( t )              :: S:: paren {{ icho [[t]] }}
  | [ t / x ] t'       :: M:: subst {{ icho (subst_tm [[t]] [[x]] [[t']]) }}
  | e [ t ]            :: M:: ctx {{ icho (appctx_ctx_tm [[e]] [[t]]) }}
  | fun ( x : T ) T' t :: :: lam
  | app t t'           :: :: app
  | cast T t           :: :: cast

path, p :: path_       ::= {{ com Path }}
  | x                  :: :: var
  | val x = new c ; p  :: :: new
  | p l p'             :: :: sel

constr, c :: constr_ ::= {{ com Constructor }}
  | Tc { </ li ( xi : Ti ) = ti // , // i IN 0 .. n /> } :: :: any

gamma, G {{ tex \Gamma }} {{ ocaml gamma }} :: gamma_ ::=  {{ coq list (var*tp) }} {{ com Environment }}
  | []                 :: :: nil
   {{ coq G_nil }}
  | G , x : T          :: :: cons
   {{ coq (cons ([[x]],[[T]]) [[G]]) }}

store, s :: store_     ::=  {{ coq list (var*constr) }} {{ com Store }}
  | []                 :: :: nil
   {{ coq s_nil }}
  | s , x |-> c        :: :: cons
   {{ coq (cons ([[x]],[[c]]) [[s]]) }}

tlabel, L {{ ocaml tL }} :: tlabel_   ::= {{ com Type label }}
  | label _c           :: :: class {{ tex {[[label]]}_c }}
  | label _a           :: :: abstract {{ tex {[[label]]}_a }}

tp, T {{ ocaml tyT }}, S {{ coq St }} {{ ocaml tyS }}, U {{ ocaml tyU }}, V {{ ocaml tyV }}, W {{ ocaml tyW }} :: tp_ ::= {{ com Type }}
  | p . L              :: :: tsel {{ com type selection }}
  | T { z => Dseq }    :: :: rfn {{ com refinement }}
  | T /\ T'            :: :: and {{ com intersection type }}
  | T \/ T'            :: :: or {{ com union type }}
  | Top                :: :: top {{ com top type }}
  | Bottom             :: :: bot {{ com bottom type }}
  | [ t / x ] T        :: M:: subst {{ icho (subst_tp [[t]] [[x]] [[T]]) }}

tpc, Tc {{ tex T_c }} {{ ocaml tyTc }}, Sc {{ tex S_c }} {{ ocaml tySc }} :: tpc_ ::= {{ com Concrete Type }}
  | p . Lc             :: :: sel
  | Tc { z => Dseq }   :: :: rfn
  | Tc /\ Tc'          :: :: and
  | Top                :: :: top
  | [ t / x ] Tc       :: M:: subst {{ icho (subst_tpc [[t]] [[x]] [[Tc]]) }}

decl, D {{ ocaml decl }} :: decl_       ::= {{ com Declaration }}
  | L : S '..' U       :: :: tp {{ com type declaration }}
  | l : S -> T         :: :: tm {{ com term declaration }}
  | [ t / x ] D        :: M:: subst {{ icho (subst_decl [[t]] [[x]] [[D]]) }}

decls, Dseq {{ tex \overline{D} }} {{ ocaml seqD }} :: Decls_ ::=
  | {}                 :: S:: empty
   {{ icho (Decls_seq nil) }}
  | </ Di // , // i /> :: :: seq
  | Dseq /\ Dseq'      :: M:: and
   {{ icho [[Dseq]] }} % TODO
  | Dseq \/ Dseq'      :: M:: or
   {{ icho [[Dseq]] }} % TODO
  | DseqBottom         :: M:: bot {{ tex \overline{D_\bot} }}
   {{ icho (Decls_seq nil) }} % TODO

ctx, e :: ctx_         ::= {{ com Context }}
  | __ l t             :: :: sel_l
  | v l __             :: :: sel_r

terminals :: terminals_ ::=
  | |->                :: :: mapsto {{ tex \mapsto }}
  | ->                 :: :: rightarrow {{ tex \rightarrow }}
  | -->                :: :: longrightarrow {{ tex \;\longrightarrow\; }}
  | =>                 :: :: Rightarrow {{ tex \Rightarrow }}
  | \/                 :: :: tand {{ tex \vee }}
  | /\                 :: :: tor {{ tex \wedge }}
  | Top                :: :: top {{ tex \top }}
  | Bottom             :: :: bot {{ tex \bot }}
  | __                 :: :: hole {{ tex [\,] }}
  | in                 :: :: in {{ tex \in }}
  | mem                :: :: mem {{ tex \ni }}
  | |-                 :: :: ts {{ tex \,\vdash\, }}
  | |=                 :: :: ms {{ tex \,\models\, }}
  | fn                 :: :: fn {{ tex \text{\sl fn} }}
  | notin              :: :: notin {{ tex \not\in }}

formula :: formula_    ::=
  | judgement          :: :: judgement
  | x |-> c in s       :: :: store_lookup
    {{ coq (store_bound [[x]] [[c]] [[s]]) }}
  | x : T in G         :: :: gamma_lookup
    {{ coq (env_bound [[x]] [[T]] [[G]]) }}
  | x notin fn ( T )   :: :: not_free_check
    {{ coq (~In [[x]] (fv_tp [[T]])) }}
  | formula1 .. formulan :: :: dots

embed
{{ coq
Notation G_nil := (@nil (var*tp)).
Definition env_bound x T G :=
  exists G1, exists G2,
    (G = List.app G1 (List.cons (x,T) G2)) /\
    ~In x (List.map (@fst var tp) G1).
Notation s_nil := (@nil (var*constr)).
Definition store_bound x c s :=
  exists s1, exists s2,
    (s = List.app s1 (List.cons (x,c) s2)) /\
    ~In x (List.map (@fst var constr) s1).
}}

subrules
  Lc <:: L
  La <:: L
  v  <:: tm
  v  <:: path
  path  <:: tm
  tpc <:: tp

contextrules
  ctx _:: tm :: tm

substitutions
  single tm var :: subst

freevars
  tm var :: fv

defns
Job :: '' ::=

 defn
 t | s --> t' | s' :: ::reduce:: red_ {{ com Reduction }} by


 --------------------------------------- :: new
 val x = new c; t | s --> t | s, x |-> c


 x |-> Tc { l0(x0:T0)=t0, .., ln(xn:Tn)=tn } in s
 ------------------------------------------------ :: sel
 x li v | s --> [v/xi] ti | s

 t | s --> t' | s'
 ----------------------- :: ctx
 e[t] | s --> e[t'] | s'

 defn
 G , s |- t : T :: ::typing:: typ_ {{ com Type Assignment }} by

 x : T in G
 ------------- :: var
 G, s |- x : T

 G, s |- t1 mem l1 : S1 -> T1
 G, s |- t2 : T2
 G, s |- T2 <: S1
 ----------------------------------------------- :: sel
 G, s |- t1 l t2 : T1

 x notin fn(T)
 G, s |- Tc wfe
 G, s |- Tc expands x </ Lj : Sj .. Uj // j/>, </ li : Vi -> Wi // i/>
 </ G, x : Tc, s |- Ti wfe // i/>
 </ G, x : Tc, s |- Vi <: Ti // i/>
 </ G, x : Tc, s |- Sj <: Uj // j/>
 G, x : Tc, s |- t : T
 </ G, x : Tc, xi : Ti, s |- ti : Wi' // i/>
 </ G, x : Tc, xi : Ti, s |- Wi' <: Wi // i/>
 --------------------------------------------------------------------- :: new
 G, s |- val x = new Tc { </ li(xi:Ti)=ti // i/> }; t : T

 defn
 G , s |- t mem D :: ::membership:: mem_ {{ com Membership }} by

 G, s |- p : T
 G, s |- T expands z </ Di // i />
 --------------------------------------- :: path
 G, s |- p mem [p/z] Di

 defn
 G , s |- T expands z Dseq :: ::expansion:: exp_ {{com Expansion }} {{ tex [[G]], [[s]] [[|-]] [[T]] \prec_[[z]] [[Dseq]] }} by

 G, s |- T expands z Dseq'
 ----------------------------------------------- :: rfn
 G, s |- T { z => Dseq } expands z Dseq /\ Dseq'

 G, s |- T1 expands z Dseq1
 G, s |- T2 expands z Dseq2
 ----------------------------------------- :: and
 G, s |- T1 /\ T2 expands z Dseq1 /\ Dseq2

 G, s |- T1 expands z Dseq1
 G, s |- T2 expands z Dseq2
 ----------------------------------------- :: or
 G, s |- T1 \/ T2 expands z Dseq1 \/ Dseq2

 G, s |- p mem L : S .. U
 G, s |- U expands z Dseq
 -------------------------- :: sel
 G, s |- p.L expands z Dseq


 ------------------------ :: top
 G, s |- Top expands z {}


 ----------------------------------- :: bot
 G, s |- Bottom expands z DseqBottom

 defn
 G , s |- S <: T :: ::subtyping:: sub_ {{com Subtyping }} by


 -------------- :: refl
 G, s |- T <: T

 G, s |- S <: T
 G, s |- S expands z Dseq'
 G, z : S, s |- Dseq' <: Dseq
 ---------------------------- :: rfn_r
 G, s |- S <: T { z => Dseq }

 G, s |- T <: T'
 ----------------------------- :: rfn_l
 G, s |- T { z => Dseq } <: T'

 G, s |- p mem L : S .. U
 G, s |- S <: U
 G, s |- S' <: S
 ------------------------- :: tsel_r
 G, s |- S' <: p.L

 G, s |- p mem L : S .. U
 G, s |- S <: U
 G, s |- U <: U'
 ------------------------- :: tsel_l
 G, s |- p.L <: U'

 G, s |- T <: T1
 G, s |- T <: T2
 --------------------- :: and_r
 G, s |- T <: T1 /\ T2

 G, s |- Ti <: T
 --------------------- :: and_l
 G, s |- T1 /\ T2 <: T

 G, s |- T <: Ti
 --------------------- :: or_r
 G, s |- T <: T1 \/ T2

 G, s |- T1 <: T
 G, s |- T2 <: T
 --------------------- :: or_l
 G, s |- T1 \/ T2 <: T


 ---------------- :: top
 G, s |- T <: Top


 ------------------- :: bot
 G, s |- Bottom <: T

 p1 | s --> p2 | s'
 G, s |- T <: p2.L
 ------------------ :: path_red
 G, s |- T <: p1.L

 defn
 G , s |- D <: D' :: ::decl_sub:: decl_sub_ {{com Declaration subsumption }} by

 G, s |- S' <: S
 G, s |- U <: U'
 --------------------------------- :: tp
 G, s |- L : S .. U <: L : S' .. U'

 G, s |- S' <: S
 G, s |- T <: T'
 --------------------------------- :: tm
 G, s |- l : S -> T <: l : S' -> T'

 defn
 G , s |- Dseq <: Dseq' :: ::decls_sub:: decls_sub by

 defn
 G , s |- T wf :: ::wf:: wf_ {{com Well-formed types }} by

 G, s |- T wfe
 G, z : T { z => Dseq }, s |- Dseq wf
 ------------------------------------ :: rfn
 G, s |- T { z => Dseq } wf

 G, s |- p mem L : S .. U
 G, s |- S wfe
 G, s |- U wfe
 ------------------------- :: tsel1
 G, s |- p.L wf

 G, s |- p mem L : Bottom .. U
 ----------------------------- :: tsel2
 G, s |- p.L wf

 G, s |- T wfe
 G, s |- T' wfe
 ------------------ :: and
 G, s |- T /\ T' wf

 G, s |- T wfe
 G, s |- T' wfe
 ------------------ :: or
 G, s |- T \/ T' wf


 ------------------ :: bot
 G, s |- Bottom wf


 -------------- :: top
 G, s |- Top wf

 defn
 G , s |- D wf :: ::decl_wf:: decl_wf_ {{com Well-formed declarations }} by

 G, s |- S wfe
 G, s |- U wfe
 --------------------------------- :: tp
 G, s |- L : S .. U wf

 G, s |- S wfe
 G, s |- T wfe
 --------------------------------- :: tm
 G, s |- l : S -> T wf

 defn
 G , s |- Dseq wf :: ::decls_wf:: decls_wf by

 defn
 G , s |- T wfe :: ::wfe:: wfe_ {{com Well-formed and expanding types }} by

 G, s |- T wf
 G, s |- T expands z Dseq
 ------------------------ :: any
 G, s |- T wfe

 defn
 G |= s :: ::ok_ctx:: ok_ctx_ {{com Consistent Context }} by

